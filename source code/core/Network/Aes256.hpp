#pragma once
#undef min

#include <iostream>
#include <vector>
#include <string>
#include <botan/hex.h>
#include <botan/auto_rng.h>
#include <botan/aes.h>
#include <botan/pbkdf.h>
#include <botan/hmac.h>
#include <botan/hash.h>
#include <botan/base64.h>
#include <botan/cipher_mode.h>

#pragma comment (lib, "botan.lib")

namespace Algorithm
{
    class Aes256 {
    private:
        Botan::SymmetricKey _key;
        Botan::SymmetricKey _authKey;
        Botan::AutoSeeded_RNG rng;

        static constexpr size_t KeyLength = 32;
        static constexpr size_t AuthKeyLength = 64;
        static constexpr size_t IvLength = 16;
        static constexpr size_t HmacSha256Length = 32;

        void Init() {
            std::string Salt = "SuperDuper";
            Botan::secure_vector<uint8_t> salt(Salt.begin(), Salt.end());
            Botan::PBKDF* pbkdf = Botan::get_pbkdf("PBKDF2(SHA-1)");
            _key = pbkdf->derive_key(KeyLength, "TXlTZWNyZXRLZXk=", salt.data(), salt.size(), 50000); // 'MySecretKey'
            Botan::SymmetricKey tmp = pbkdf->derive_key(AuthKeyLength + KeyLength, "TXlTZWNyZXRLZXk=", salt.data(), salt.size(), 50000);
            Botan::secure_vector<uint8_t> tmpvec(tmp.begin() + KeyLength, tmp.end());
            _authKey = Botan::SymmetricKey(tmpvec);
        }

    public:
        Aes256() {
            Init();
        }

        // Copy assignment operator
        Aes256& operator=(const Aes256& other) {
            if (this != &other) {
                _key = other._key;
                _authKey = other._authKey;
            }
            return *this;
        }

        Botan::secure_vector<uint8_t> Encrypt(Botan::secure_vector<uint8_t> input) {
            if (input.size() == 0) {
                throw std::runtime_error("Aes256::Encrypt::input can not be null.");
                return {};
            }

            Botan::secure_vector<uint8_t> tmp = _key.bits_of();
            tmp.resize(KeyLength);
            Botan::SymmetricKey aes_key(tmp);

            auto enc = Botan::Cipher_Mode::create("AES-256/CBC/PKCS7", Botan::Cipher_Dir::ENCRYPTION);
            enc->set_key(aes_key);
            Botan::secure_vector<uint8_t> iv = rng.random_vec(enc->default_nonce_length());
            enc->start(iv);
            enc->finish(input);
            Botan::secure_vector<uint8_t> encrypted = input;

            auto hmac = Botan::MessageAuthenticationCode::create_or_throw("HMAC(SHA-256)");
            hmac->set_key(_authKey);
            hmac->update(iv);
            hmac->update(encrypted);
            Botan::secure_vector<uint8_t> hmac_result = hmac->final();

            Botan::secure_vector<uint8_t> result(hmac_result);
            result += iv;
            result += encrypted;
            return result;
        }

        std::string Encrypt(const std::string& input) {
            Botan::secure_vector<uint8_t> binary_data(input.data(), input.data() + input.length());
            return Botan::base64_encode(Encrypt(binary_data));
        }

        Botan::secure_vector<uint8_t> Decrypt(Botan::secure_vector<uint8_t> input) {
            Botan::secure_vector<uint8_t> iv_data(input.begin() + HmacSha256Length, input.end());
            auto hmac = Botan::MessageAuthenticationCode::create_or_throw("HMAC(SHA-256)");
            hmac->set_key(_authKey);
            hmac->update(iv_data);
            Botan::secure_vector<uint8_t> hmac_result = hmac->final();

            if (!Botan::same_mem(hmac_result.data(), input.data(), HmacSha256Length)) {
                throw std::runtime_error("Invalid message authentication code (MAC).");
                return {};
            }

            Botan::secure_vector<uint8_t> iv(input.begin() + HmacSha256Length, input.begin() + HmacSha256Length + IvLength);
            Botan::secure_vector<uint8_t> ciphertext(input.begin() + HmacSha256Length + IvLength, input.end());
            Botan::SymmetricKey aes_key(_key);

            auto enc = Botan::Cipher_Mode::create("AES-256/CBC/PKCS7", Botan::Cipher_Dir::DECRYPTION);
            enc->set_key(aes_key);
            enc->start(iv);
            enc->finish(ciphertext);
            Botan::secure_vector<uint8_t> decrypted = ciphertext;

            return decrypted;
        }

        std::string Decrypt(const std::string& input) {
            if (input.empty()) {
                return "";
            }
            Botan::secure_vector<uint8_t> vec = Decrypt(Botan::base64_decode(input));
            std::string tmp(vec.begin(), vec.end());
            return tmp;
        }

    };


}
