#pragma once

#include <iostream>
#include <sstream>
#include <vector>
#include <windows.h>
#include <zlib.h>

namespace Network
{
    class ProtocolZip {
    private:
        static std::vector<unsigned char> SwapBytes(const std::vector<unsigned char>& v) {
            std::vector<unsigned char> r(v.size());
            int j = static_cast<int>(v.size()) - 1;
            for (size_t i = 0; i < r.size(); i++) {
                r[i] = v[j];
                j--;
            }
            return r;
        }

    public:
        static std::vector<unsigned char> Compress(const std::vector<unsigned char>& input)
        {
            std::vector<uint8_t> compressedResult;

            // Prepare the length of the input and write it as 4 bytes
            uint32_t length = static_cast<uint32_t>(input.size());
            std::vector<uint8_t> lengthBytes(4);
            lengthBytes[0] = (length >> 24) & 0xFF;
            lengthBytes[1] = (length >> 16) & 0xFF;
            lengthBytes[2] = (length >> 8) & 0xFF;
            lengthBytes[3] = length & 0xFF;

            lengthBytes = SwapBytes(lengthBytes);

            compressedResult.insert(compressedResult.end(), lengthBytes.begin(), lengthBytes.end());

            // Initialize zlib stream
            z_stream stream;
            stream.zalloc = Z_NULL;
            stream.zfree = Z_NULL;
            stream.opaque = Z_NULL;
            deflateInit2(&stream, Z_DEFAULT_COMPRESSION, Z_DEFLATED, 16 + MAX_WBITS, 8, Z_DEFAULT_STRATEGY);

            stream.avail_in = static_cast<uInt>(input.size());
            stream.next_in = (Bytef*)input.data();

            std::vector<uint8_t> buffer(1024);
            do {
                stream.avail_out = buffer.size();
                stream.next_out = (Bytef*)buffer.data();
                int ret = deflate(&stream, Z_FINISH);
                if (ret == Z_STREAM_END) {
                    compressedResult.insert(compressedResult.end(), buffer.begin(), buffer.begin() + (buffer.size() - stream.avail_out));
                    break;
                }
                compressedResult.insert(compressedResult.end(), buffer.begin(), buffer.begin() + (buffer.size() - stream.avail_out));
            } while (stream.avail_out == 0);

            deflateEnd(&stream);
            return compressedResult;
        }

        static std::vector<unsigned char> Decompress(const std::vector<unsigned char>& input)
        {
            std::istringstream sourceStream(std::string(input.begin(), input.end()));

            std::vector<uint8_t> lengthBytes(4);
            sourceStream.read(reinterpret_cast<char*>(lengthBytes.data()), 4);

            int length = *reinterpret_cast<int*>(lengthBytes.data());
            std::vector<uint8_t> decompressedResult(length);

            z_stream stream;
            stream.zalloc = Z_NULL;
            stream.zfree = Z_NULL;
            stream.opaque = Z_NULL;
            stream.avail_in = 0;
            stream.next_in = Z_NULL;
            int ret = inflateInit2(&stream, 16 + MAX_WBITS);
            if (ret != Z_OK)
                return {};

            stream.avail_in = static_cast<uInt>(input.size() - 4);
            stream.next_in = (Bytef*)&input[4];

            stream.avail_out = static_cast<uInt>(decompressedResult.size());
            stream.next_out = (Bytef*)decompressedResult.data();

            ret = inflate(&stream, Z_NO_FLUSH);
            if (ret != Z_STREAM_END) {
                inflateEnd(&stream);
                return {};
            }

            inflateEnd(&stream);
            return decompressedResult;
        }

    };
}


