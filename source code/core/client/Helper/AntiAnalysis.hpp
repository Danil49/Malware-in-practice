#pragma once

#include <iostream>
#include <Windows.h>
#include <Psapi.h>
#include <vector>
#include <string>
#include <sstream>
#include <cstring>
#include <shlobj_core.h>
#include <filesystem>
#include <thread>
#include <comdef.h>
#include <Wbemidl.h>
#include <wtsapi32.h>
#include <tchar.h>
#include <intrin.h>
#include <TlHelp32.h>
#include <winternl.h>

#pragma comment(lib, "wbemuuid.lib")
#pragma comment(lib, "wtsapi32.lib")

namespace Helper
{
	class AntiVM {
	public:
		static void RunAntiVM()
		{
			if (IsSandboxDetected() || LoadedDlls()) {
				for (long long int i = 0; ++i; (&i)[i] = i); // crash the program without exit() using
				*((char*)NULL) = 0;
			}
		}

	private:
		static const bool LoadedDlls() {
			std::wstring input = (
				L"avghookx.dll,"
				"avghooka.dll,"
				"snxhk.dll,"
				"sbiedll.dll,"
				"dbghelp.dll,"
				"api_log.dll,"
				"dir_watch.dll,"
				"pstorec.dll,"
				"vmcheck.dll,"
				"wpespy.dll,"
				"cmdvrt64.dll,"
				"cmdvrt32.dll");
			std::vector<std::wstring> szDlls;
			std::wstringstream ss(input);
			std::wstring token;
			while (std::getline(ss, token, L',')) {
				szDlls.push_back(token);
			}

			HMODULE hDll;
			for (int i = 0; i < szDlls.size(); i++)
			{
				hDll = GetModuleHandle(szDlls[i].c_str());
				if (hDll != NULL) {
					return true;
				}
			}
			return false;
		}

		static const bool IsSandboxDetected()
		{
			try
			{
				HRESULT hres;
				hres = CoInitialize(NULL);
				hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);

				IWbemLocator* pLoc = 0;
				hres = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&pLoc);
				if (FAILED(hres)) {
					CoUninitialize();
					return false;
				}

				IWbemServices* pSvc = 0;
				hres = pLoc->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
				if (FAILED(hres)) {
					//cout << "Sandbox Detected " << endl;
					pSvc->Release();
					pLoc->Release();
					CoUninitialize();
					return true;
				}
				pSvc->Release();
				pLoc->Release();
				CoUninitialize();
			}
			catch (...) {}

			return false;
		}

	};

#ifndef STATUS_INFO_LENGTH_MISMATCH
#define STATUS_INFO_LENGTH_MISMATCH ((DWORD)0xC0000004L)
#endif
#ifndef STATUS_DATATYPE_MISALIGNMENT
#define STATUS_DATATYPE_MISALIGNMENT ((DWORD)0x80000002L)
#endif
	class AntiDebug {
	public:

		static void RunAntiDebug()
		{
			if (CheckSleep() || CheckDebuggerPresent()) {
				for (long long int i = 0; ++i; (&i)[i] = i); // crash the program without exit() using
				*((char*)NULL) = 0;
			}
		}

	private:
		static DWORD GetProcessIdFromName(LPCTSTR szProcessName)
		{
			PROCESSENTRY32 pe32;
			SecureZeroMemory(&pe32, sizeof(PROCESSENTRY32));

			HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

			if (hSnapshot == INVALID_HANDLE_VALUE) {
				return 0;
			}

			pe32.dwSize = sizeof(PROCESSENTRY32);

			if (Process32First(hSnapshot, &pe32) == FALSE) {
				CloseHandle(hSnapshot);
				return 0;
			}

			if (_tcsicmp(pe32.szExeFile, szProcessName) == 0) {
				CloseHandle(hSnapshot);
				return pe32.th32ProcessID;
			}

			while (Process32Next(hSnapshot, &pe32)) {
				if (_tcsicmp(pe32.szExeFile, szProcessName) == 0) {
					CloseHandle(hSnapshot);
					return pe32.th32ProcessID;
				}
			}
			CloseHandle(hSnapshot);
			return 0;
		}

		static const bool CheckDebuggerPresent()
		{
			try
			{
				PPEB pPEB = (PPEB)__readgsqword(0x60);
				if (pPEB->BeingDebugged) { return true; }
				if (IsDebuggerPresent()) { return true; }
			}
			catch (...) {}
			return false;
		}

		static const bool CheckSleep()
		{
			DWORD TickCount = GetTickCount64();
			Sleep(3000);
			return !(GetTickCount64() - TickCount > 2000);
		}

	};

}