#include "Connection.hpp"
#include "Network.hpp"
#include "Helper.hpp"
#include "Settings.hpp"
#include <utility>

namespace Connection {

    std::vector<uint8_t> ServerSocket::Buffer;
    long ServerSocket::HeaderSize;
    long ServerSocket::Offset;
    int ServerSocket::server_socket;
    std::vector<Client> ServerSocket::Clients(max_clients);
    std::mutex Packet::SendSync;

    void ServerSocket::InitializeServer(int Port) {
        // Initialize OpenSSL
        SSL_library_init();
        OpenSSL_add_all_algorithms();
        SSL_load_error_strings();
        SSL_CTX* ctx = SSL_CTX_new(TLS_server_method());
        if (!ctx) {
            std::cerr << "Error creating SSL context." << std::endl;
            system("pause");
            return;
        }

        EVP_PKEY* pkey;
        X509* x509;
        if (!Helper::fileExists(Settings::CertificateName)) {
            // Load new server certificate and private key
            pkey = generatePrivateKey();
            x509 = generateCertificate(pkey);
            // Create a PKCS12 structure
            PKCS12* p12 = PKCS12_create("mypassword", "ServerCertificate", pkey, x509, nullptr, 0, 0, 0, 0, 0);

            // Write the PKCS12 structure to a .p12 file
            FILE* p12_file = fopen(Settings::CertificateName.data(), "wb");
            if (p12_file == nullptr) {
                std::cerr << "Error creating new server certificate." << std::endl;
                return;
            }
            i2d_PKCS12_fp(p12_file, p12);
            fclose(p12_file);
            PKCS12_free(p12);
        }
        else
        {
            std::pair<X509*, EVP_PKEY*> config = extractCertificateFromPKCS12(Settings::CertificateName, "mypassword");
            x509 = config.first;
            pkey = config.second;
        }

        SSL_CTX_use_certificate(ctx, x509);
        SSL_CTX_use_PrivateKey(ctx, pkey);

        // Create TCP socket
        WSADATA wsaData;
        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
            std::cerr << "Error initializing Winsock" << std::endl;
            system("pause");
            return;
        }

        // initialize variables
        HeaderSize = 4;
        Offset = 0;
        Buffer.assign(HeaderSize, 0);
        int new_socket, opt = true, addresslen, max_sd, tmp;
        //set of socket descriptors  
        fd_set readfds;

        for (int i = 0; i < max_clients; i++) {
            Clients[i].socket = 0;
            Clients[i].ssl = SSL_new(ctx);
        }

        server_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (server_socket == -1) {
            std::cerr << "Error creating socket." << std::endl;
            system("pause");
            return;
        }
        if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt)) == -1) {
            std::cerr << "Error setting multiple connections." << std::endl;
            system("pause");
            return;
        }

        // Bind socket to address
        struct sockaddr_in server_addr;
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = INADDR_ANY;
        server_addr.sin_port = htons(Port);

        if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
            std::cerr << "Error binding socket." << std::endl;
            system("pause");
            return;
        }

        // Listen for connections
        if (listen(server_socket, 5) == -1) {
            std::cerr << "Error listening for connections." << std::endl;
            system("pause");
            return;
        }
        std::cout << "Server listening on port " << Port << std::endl;

        addresslen = sizeof(server_addr);
        while (TRUE)
        {
            //clear the socket set
            FD_ZERO(&readfds);

            //add server socket to set
            FD_SET(server_socket, &readfds);
            max_sd = server_socket;

            //add child sockets to set  
            for (int i = 0; i < max_clients; i++)
            {
                tmp = Clients[i].socket;
                if (tmp > 0) {
                    FD_SET(tmp, &readfds);
                }
                if (tmp > max_sd) {
                    max_sd = tmp;
                }
            }

            //wait indefinitely for an activity on one of the sockets 
            int activity = select(max_sd + 1, &readfds, NULL, NULL, NULL);

            if ((activity < 0) && (errno != EINTR))
            {
                printf("select error");
            }

            //incoming connection
            if (FD_ISSET(server_socket, &readfds))
            {
                if ((new_socket = accept(server_socket, (struct sockaddr*)&server_addr, (socklen_t*)&addresslen)) == -1) {
                    std::cerr << "Accept error." << std::endl;
                    system("pause");
                    return;
                }

                //new connection
                std::cout << "New connection" << std::endl;
                for (int i = 0; i < max_clients; i++) {
                    if (Clients[i].socket == 0) {
                        Clients[i].socket = new_socket;
                        Clients[i].ip = inet_ntoa(server_addr.sin_addr);
                        SSL_set_fd(Clients[i].ssl, Clients[i].socket);
                        if (SSL_accept(Clients[i].ssl) <= 0) {
                            std::cerr << "Error accepting SSL handshake." << std::endl;
                            SSL_free(Clients[i].ssl);
                            Clients[i].socket = 0;
                            Clients[i].ip = "";
                        }
                        // request HWID from client
                        //std::thread(Packet::Send, Clients[i].ssl, Network::EncodeToBytes("HWID")).detach();
                        break;
                    }
                }
                Helper::PrintClients();
            }
            //some operation on some other socket 
            for (int i = 0; i < max_clients; i++)
            {
                tmp = Clients[i].socket;

                if (FD_ISSET(tmp, &readfds))
                {
                    //Check if it was for closing and read incoming message 
                    //int bytes_received = SSL_read(Clients[i].ssl, buffer, sizeof(buffer));
                    int received = SSL_read(Clients[i].ssl, Buffer.data()+Offset, HeaderSize); //read the length of received message
                    if (received > 0) {
                        Offset += received;
                        HeaderSize -= received;
                        if (HeaderSize == 0) {
                            // calculate the length
                            HeaderSize = static_cast<long>(
                                (static_cast<uint32_t>(Buffer[0]) << 0) |
                                (static_cast<uint32_t>(Buffer[1]) << 8) |
                                (static_cast<uint32_t>(Buffer[2]) << 16) |
                                (static_cast<uint32_t>(Buffer[3]) << 24)
                                );
                            //std::cout << "/// Client Buffersize " << HeaderSize << " Bytes ///" << std::endl;
                            if (HeaderSize > 0)
                            {
                                Offset = 0;
                                Buffer.assign(HeaderSize, 0);
                                while (HeaderSize > 0) {
                                    int rc = SSL_read(Clients[i].ssl, Buffer.data() + Offset, HeaderSize);
                                    if (rc <= 0) {
                                        break;
                                    }
                                    Offset += rc;
                                    HeaderSize -= rc;
                                    if (HeaderSize < 0) {
                                        break;
                                    }
                                }
                                std::thread(Packet::Read, Buffer, i).detach();
                                Offset = 0;
                                HeaderSize = 4;
                                std::vector<uint8_t>().swap(Buffer);
                                Buffer.assign(HeaderSize, 0);
                            }
                            else {
                                HeaderSize = 4;
                                Offset = 0;
                                std::vector<uint8_t>().swap(Buffer);
                                Buffer.assign(HeaderSize, 0);
                            }
                        }
                    }
                    else {
                        //Somebody disconnected
                        std::cerr << "Error receiving data or client is disconnected" << std::endl;
                        //Close the socket 
                        SSL_free(Clients[i].ssl);
                        closesocket(tmp);
                        Clients[i].socket = 0;
                        Clients[i].ip = "";
                        //system("pause");
                    }
                   
                }
            }
        }

        // Close connection
        //SSL_shutdown(ssl);
        //SSL_free(ssl);
        //closesocket(client_socket);
        closesocket(server_socket);

        // Cleanup
        SSL_CTX_free(ctx);

        system("pause");
    }

    bool Packet::Send(SSL* client, std::vector<uint8_t> msg)
    {
        std::lock_guard<std::mutex> lock(SendSync);
        try
        {
            int sendResult = SSL_write(client, reinterpret_cast<const char*>(msg.data()), static_cast<int>(msg.size()));
            SSL_write(client, "", 0); //Flush the SSL buffer
            if (sendResult == -1) {
                std::cout << "Failed to send data using SSL in Send() function" << std::endl;
                return false;
            }
            return true;
        }
        catch (...) {
            std::cerr << "Unknown error in Send() function" << std::endl;
            return false;
        }
    }

    void Packet::Read(std::vector<uint8_t> msg, int clientIdx)
    {
        std::vector<uint8_t> tmp = Network::ProtocolZip::Decompress(msg);
        std::string data(tmp.begin(), tmp.end());
        std::string packet(tmp.begin(), tmp.begin() + 4);
        if (packet == "HWID") {
            // separate data HWID:value
            size_t pos = data.find(':');
            std::string hwid = data.substr(pos + 1);
            ServerSocket::Clients[clientIdx].hwid = hwid;
            //std::cout << "CLIENT HWID: " << ServerSocket::Clients[clientIdx].hwid << std::endl;
        }
        else if (packet == "LOGS") {
            //save zip
            size_t pos = data.find(':');
            std::string logs = data.substr(pos + 1);
            std::vector<uint8_t> vec(logs.begin(), logs.end());
            Helper::WriteLogs(ServerSocket::Clients[clientIdx].ip, ServerSocket::Clients[clientIdx].hwid, vec);
        }
    }


}
