#pragma once

#include <iostream>
#include <cstring>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <WinSock2.h>
#include <WS2tcpip.h>
#include <signal.h>
#include <mutex>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/pkcs12.h>

#pragma comment(lib, "crypt32.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "libssl.lib")
#pragma comment(lib, "libcrypto.lib")

namespace Connection {

    static EVP_PKEY* generatePrivateKey()
    {
        EVP_PKEY* pkey = NULL;
        EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
        EVP_PKEY_keygen_init(pctx);
        EVP_PKEY_CTX_set_rsa_keygen_bits(pctx, 2048);
        EVP_PKEY_keygen(pctx, &pkey);
        return pkey;
    }

    static X509* generateCertificate(EVP_PKEY* pkey)
    {
        X509* x509 = X509_new();
        X509_set_version(x509, 2);
        ASN1_INTEGER_set(X509_get_serialNumber(x509), 0);
        X509_gmtime_adj(X509_get_notBefore(x509), 0);
        X509_gmtime_adj(X509_get_notAfter(x509), (long)60 * 60 * 24 * 365);
        X509_set_pubkey(x509, pkey);

        X509_NAME* name = X509_get_subject_name(x509);
        X509_NAME_add_entry_by_txt(name, "C", MBSTRING_ASC, (const unsigned char*)"US", -1, -1, 0);
        X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, (const unsigned char*)"CN", -1, -1, 0);
        X509_set_issuer_name(x509, name);
        X509_sign(x509, pkey, EVP_md5());
        return x509;
    }

    static std::pair<X509*, EVP_PKEY*> extractCertificateFromPKCS12(const std::string& p12FilePath, const std::string& password) {
        PKCS12* p12 = nullptr;
        FILE* p12File = fopen(p12FilePath.c_str(), "rb");
        if (!p12File) {
            std::cerr << "Error opening PKCS12 file." << std::endl;
            return {};
        }
        p12 = d2i_PKCS12_fp(p12File, nullptr);
        fclose(p12File);
        if (!p12) {
            std::cerr << "Error reading PKCS12 file." << std::endl;
            return {};
        }

        EVP_PKEY* pkey = nullptr;
        X509* cert = nullptr;
        STACK_OF(X509)* ca = nullptr;
        if (!PKCS12_parse(p12, password.c_str(), &pkey, &cert, &ca)) {
            std::cerr << "Error parsing PKCS12 file." << std::endl;
            PKCS12_free(p12);
            return {};
        }

        PKCS12_free(p12);
        if (ca)
            sk_X509_pop_free(ca, X509_free);

        return std::make_pair(cert, pkey);
    }

    const int max_clients = 20;
    static X509* ServerCertificate;

    class Client {
    public:
        int socket;
        SSL* ssl;
        std::string ip;
        std::string hwid;
    };

    class ServerSocket {
    public:
        static int server_socket;
        static std::vector<uint8_t> Buffer;
        static long HeaderSize;
        static long Offset;
        static std::vector<Client> Clients;
        static void InitializeServer(int Port);
    };

    class Packet {
    private:
        static std::mutex SendSync;
    public:
        static bool Send(SSL* client, std::vector<uint8_t> msg);

        static void Read(std::vector<uint8_t> msg, int clientIdx);

    };
}
